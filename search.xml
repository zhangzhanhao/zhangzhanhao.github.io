<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[this的值到底是什么]]></title>
      <url>%2F2016%2F11%2F21%2Fthis%E6%8C%87%E5%90%91%2F</url>
      <content type="text"><![CDATA[从开始学了javascript以来，遇到this的指向问题时，虽然到最后问题能够解决，但对于这个this的值一直比较模糊不清。今天在知乎上看到了一篇讲this的值得文章，收益匪浅，所以转载来分享。 作者及出处作者：方应杭链接：https://zhuanlan.zhihu.com/p/23804247来源：知乎 正文你可能遇到过这样的 JS 面试题：123456789var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 打印出的 this 是 objbar() // 打印出的 this 是 window 请解释最后两行函数的值为什么不一样。初学者关于 this 的理解一直很模糊。今天这篇文章就要一次讲清楚了。而且这个解释，你在别的地方看不到。看懂这篇文章，所有关于 this 的面试题，都是小菜。有用请点赞。 函数调用首先需要从函数的调用开始讲起。JS（ES5）里面有三种函数调用形式：123func(p1, p2) obj.child.method(p1, p2)func.call(context, p1, p2) // 先不讲 apply 一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：1func.call(context, p1, p2) 其他两种都是语法糖，可以等价地变为 call 形式：12345func(p1, p2) 等价于func.call(undefined, p1, p2)obj.child.method(p1, p2) 等价于obj.child.method.call(obj.child, p1, p2) 请记下来。（我们称此代码为「转换代码」，方便下文引用）至此我们的函数调用只有一种形式：1func.call(context, p1, p2) 这样，this 就好解释了this，就是上面代码中的 context。就这么简单。 this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。 先看 func(p1, p2) 中的 this 如何确定：当你写下面代码时12345function func()&#123; console.log(this)&#125;func() 等价于12345function func()&#123; console.log(this)&#125;func.call(undefined) // 可以简写为 func.call() 按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则： 如果你传的 context 不是一个对象，那么 window 对象就是默认的 context因此上面的打印结果是 window。如果你希望这里的 this 不是 window，很简单：1func.call(obj) // 那么里面的 this 就是 obj 对象了 再看 obj.child.method(p1, p2) 的 this 如何确定1234567var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;obj.foo() 按照「转换代码」，我们将 obj.foo() 转换为1obj.foo.call(obj) 好了，this 就是 obj。搞定。回到题目：12345678910111213var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 转换为 obj.foo.call(obj)，this 就是 objbar() // 转换为 bar.call()// 由于没有传 context// 所以 this 就是 undefined// 最后浏览器给你一个默认的 this —— window 对象 总结 this 就是你 call 一个函数时，传入的 context。 如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。以后你遇到所有跟 this 有关的笔试题，都不会有疑问了。 完。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJS+Mongodb小项目]]></title>
      <url>%2F2016%2F11%2F19%2FnodejsObj%2F</url>
      <content type="text"><![CDATA[这个小项目我们实现一个类似慕课网的常见的网络学习平台，这次主要实现了路由跳转、注册、登录、登录状态保存、课程管理、连接数据库实现前后端交互。有一些地方的样式和布局没有细做还望见谅。 环境web开发框架我使用Express，数据库mongodb，服务端nodejs，前端布局使用jade，用到的其他插件：mongoose实现与数据库的连接，supervisor实时监控代码更新，express-session做登录控制。环境的配置和插件的安装在这里就不细说了。百度一下安装方法很详细。 文件配置主文件项目目录下终端运行：1234$ express MyApp$ cd MyApp$ npm install$ supervisor bin/www 这四步运行完之后网页打开127.0.0.1:3000 就可以看到nodeJS已经开始工作了。 Views由于各个页面都有相同的头部和底部，所以在views目录下创建header.jade和foot.jade这样在每个页面就都可以引入，不用写很多遍。创建课程页class.jade直播和点播都在这个页面创建登录页login.jade和注册页reg.jade创建课程管理页setclass.jade这里说下class.jade布局的写法，因为所有课程都是从数据库吐出来的，所以在渲染课程list时要根据数据的个数，动态渲染list有多少条，在jade中可以使用each in来遍历数据1234567891011div.kecheng ul if(data) -each item,index in data li.listone div.img.fl p.fl= item.title p.fl= item.des p.fl span ￥ span= item.price 其他页面具体的布局就不细说了，大家可以下载我的源文件查看， 设置路由在app.js中引入两个路由文件并设置12345var index = require('./routes/index');var ke = require('./routes/class')·······app.use('/', index);app.use('/class',ke) class.js在routes文件夹下创建另一个路由class.js由于直播和点播在一个页面,所以在链接时我给的是/class/type=1和/class/type=2，class.js代码：1234567891011121314151617var express = require('express');var router = express.Router();var mongo = require("../model/db");router.get('/type=1', function(req, res, next) &#123; mongo.kecheng.find(&#123;"type":"直播"&#125;,function (err,data) &#123; res.render('class', &#123; title: "直播" , data:data&#125;); &#125;)&#125;);router.get('/type=2', function(req, res, next) &#123; mongo.kecheng.find(&#123;"type":"点播"&#125;,function (err,data) &#123; res.render('class', &#123; title: '点播' ,data:data&#125;); &#125;)&#125;);module.exports = router 里面关于数据库的操作我们后面再说，这里主要get到/type=1或/type=2都响应一个class页面。 index.jsget各个字段，响应不同页面123456789101112router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: '首页' &#125;);&#125;);router.get('/login', function(req, res, next) &#123; res.render('login', &#123; title: '登录' &#125;);&#125;);router.get('/reg', function(req, res, next) &#123; res.render('reg', &#123; title: '注册' &#125;);&#125;);router.get('/setclass', function(req, res, next) &#123; res.render('setclass', &#123; title: '上传课程' &#125;);&#125;); 连接数据库本地终端找到数据库文件后启动1./mongod 在项目目录下创建model文件夹用来放置连接数据库文件，文件夹下创建db.js。使用插件monngoose来对数据库进行操作12345678910111213141516171819var mongoose = require("mongoose");mongoose.connect("mongodb://127.0.0.1/user");var userSchema = new mongoose.Schema(&#123; username: String, password: String,&#125;);var classSchema = new mongoose.Schema(&#123; title: String, des: String, type: String, price: String&#125;);module.exports=&#123;kecheng:mongoose.model("class",classSchema,"class"), user:mongoose.model("userMo",userSchema,"userMo") &#125; 数据库下我们一共有两个大集合userSchema和classSchema，一个用来存储用户名和密码，一个用来存储课程信息。 登录验证1234567891011121314151617181920212223242526272829303132var mongo = require("../model/db") //引入操作数据库文件 . . .router.post('/login_k',function (req,res,next) &#123; var username=req.body.username var password=req.body.password mongo.user.findOne(&#123;"username":username&#125;,function (err,user) &#123; console.log(user) if(user)&#123; if(user.password==password)&#123; req.session.user = 1, res.send(&#123; req:req.session, success:1, info:"登录成功" &#125;) &#125;else&#123; res.send(&#123; success:0, info:"用户名或密码错误" &#125;) &#125; &#125;else&#123; res.send(&#123; success:0, info:"用户不存在" &#125;) &#125; &#125;)&#125;) 当服务器post到/login_k后取出参数字段在数据库中查找username是否有该用户，没有该用户就返回success:0,info:”用户不存在”，用户存在就检测密码，密码一致返回session和succsee:1,info:”登录成功”，前端在获取success:1时就会在浏览器种下cookie为期半个小时，期间用户再次进入时就不需要登录，头部右侧也会由登录注册变成注销按键。密码不一致则返回success:0,info:”用户名或密码错误” 注册1234567891011121314151617181920212223242526272829303132333435router.post('/login_reg',function (req,res,next) &#123; var username=req.body.username var password=req.body.password mongo.user.findOne(&#123;"username":username&#125;,function(err,user)&#123; if(err)&#123; res.send(&#123; success:0, info:"注册失败" &#125;) &#125; if(user)&#123; res.send(&#123; success:0, info:"用户已存在" &#125;) &#125;else&#123; mongo.user.create(&#123; username:username, password:password &#125;,function (err,data) &#123; if(err)&#123; res.send(&#123; success:0, info:"注册失败" &#125;) &#125; res.send(&#123; success:1, info:"注册成功" &#125;) &#125;) &#125; &#125;)&#125;) 与登录的原理基本相同，检测到用户名就会显示用户名已存在，没有该用户，则会在数据库中创建一个这个用户，这里需要注意12345mongo.user.create(&#123; username:username, password:password &#125;,function (err,data) &#123; …… 123456……var userSchema = new mongoose.Schema(&#123; username: String, password: String,&#125;);…… 创建用户时使用的字段（冒号前面的username）要和数据库操作文件中的username相同。 课程管理123456789101112131415161718router.post('/setclass',function (req,res,next) &#123; var title=req.body.title var type=req.body.type var des=req.body.des var price=req.body.price mongo.kecheng.create(&#123; title: title, des: des, type: type, price: price &#125;,function (err,data) &#123; if(err)&#123;return&#125; res.send(&#123; success:1, info:"上传成功" &#125;) &#125;)&#125;) 同样也需要注意到使用字段和数据库操作文件中相一致。 class页因为直播和点播使用的是同一个页面，所以在点直播时要显示直播的list，点点播时要显示点播的list，细心人可能发现了，我在上传课程时有一个type字段，会设置是直播还是点播。当然在点直播点播页面时也就会到数据库中查找相应的type，mongo.kecheng.find（{……})找到所有符合要求的信息返回前端渲染页面。 遇到的坑数据库操作文件坑点之前在model文件夹下创建了两个数据库操作文件，想一个用来登录注册，一个用来管理课程，但在第二个数据库操作文件引入的时候就会报错。 解决办法把两个文件合并成一个，最后以对象的形式暴露出去。 class.jade坑点当直播课程为空时，网页无法渲染，会报错。 解决办法加入if判断 数据库占用坑点有时数据库进程被关闭后，重新启动时会显示0.0.0.0：27017已经被占用。 解决办法重新开一个终端输入1ps aux|grep mongod 找到对应进程id杀死1kill -9 pid 项目始终被监控坑点刚开始做时每次运行express myApp都会报错，而且发现jade文件被自动转换成了html又没有开任何进程。 解决办法发现这个是webstorm的问题，把整个webstorm软件关掉，再重新开启一遍就好了。 源码下载：https://github.com/zhangzhanhao/nodejsObj]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJS+Socket.io搭建简易聊天室]]></title>
      <url>%2F2016%2F11%2F12%2Fsocket%2F</url>
      <content type="text"><![CDATA[前端一直是一块充满惊喜的土地，不仅是那些富有创造性的页面，还有那些惊赞的效果及不断推出的新技术。像node.js这样的后端开拓者直接将前端人员的能力扩大到了后端。瞬间就有了一统天下的感觉，来往穿梭于前后端之间代码敲得飞起，从此由前端晋升为’前后端’。 需要用到的插件mime1$ npm install mime socket.io1$ npm install socket.io socket.io根据官网代码分为 服务端12345678910111213141516171819202122232425var app = require('http').createServer(handler)var io = require('socket.io')(app);var fs = require('fs');app.listen(80);function handler (req, res) &#123; fs.readFile(__dirname + '/index.html', function (err, data) &#123; if (err) &#123; res.writeHead(500); return res.end('Error loading index.html'); &#125; res.writeHead(200); res.end(data); &#125;);&#125;io.on('connection', function (socket) &#123; socket.emit('news', &#123; hello: 'world' &#125;); socket.on('my other event', function (data) &#123; console.log(data); &#125;);&#125;); 客户端12345678&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://localhost'); socket.on('news', function (data) &#123; console.log(data); socket.emit('my other event', &#123; my: 'data' &#125;); &#125;);&lt;/script&gt; 参考官方代码我做了一个简易聊天室demo以下为我所实现的代码 服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//引入部分var http=require("http")var fs=require("fs")var mime=require("mime")var server=http.createServer(handle)//绑定服务器var io=require("socket.io")(server)function handle(req,res) &#123; var filepath="" if(req.url=="/")&#123; filepath="./public/html/index.html" &#125;else&#123; filepath="./public"+req.url &#125; serverStatic(res,filepath)&#125;function serverStatic(res,filepath) &#123; fs.exists(filepath,function (exists) &#123; if(exists)&#123; fs.readFile(filepath,function (err,data) &#123; if(err)&#123; send404(res) &#125; res.writeHead(200,&#123;"Content-Type":mime.lookup(filepath)&#125;) res.end(data) &#125;) &#125;else&#123; send404(res) &#125; &#125;)&#125;var num=0;io.on('connection', function (socket) &#123; //emit(事件名，&#123;发射主题&#125;) //on(事件名，接收回调) //服务端与客户端一一对应 num++; console.log(num) function fasong() &#123; fs.readFile("./tsconfig.json","utf-8",function (err,data) &#123; if(err)&#123;return&#125; var data=JSON.parse(data) io.sockets.emit('ret',&#123; hello: data.mesg ,num:num&#125;); &#125;) &#125; fasong() socket.on('message', function (info) &#123; fs.readFile("./tsconfig.json","utf-8",function (err,data) &#123; if(err)&#123;return&#125; var data=JSON.parse(data) data.mesg.push(info) fs.writeFile("./tsconfig.json",JSON.stringify(data),function () &#123; fasong() &#125;) &#125;) &#125;);&#125;);function send404(res) &#123; res.writeHead(404,&#123;"Content-Type":"text/plain"&#125;) res.end("404 NOT FOUND")&#125;server.listen(3000,function () &#123; &#125;) 需要解释一下的是，在connection事件的回调函数中，socket表示的是当前连接到服务器的那个客户端。所以代码socket.emit(‘foo’)则只有自己收得到这个事件，而socket.broadcast.emit(‘foo’)则表示向除自己外的所有人发送该事件，另外，上面代码中，io表示服务器整个socket连接，所以代码io.sockets.emit(‘foo’)表示所有人都可以收到该事件。 客户端JS1234567891011121314151617181920var socket = io('http://10.80.13.132:3000'); var mes=document.querySelector(".mes") var btn=document.querySelector(".btn") var ul=document.querySelector('ul') var chat=document.querySelector(".chat") btn.onclick=function (ev) &#123; ev.preventDefault(); var message=mes.value socket.emit('message', &#123; Info: message &#125;); &#125; socket.on('ret', function (data) &#123; ul.innerHTML='' for(var i=0;i&lt;data.hello.length;i++)&#123; var li=document.createElement("li") li.innerHTML=data.hello[i].Info ul.appendChild(li) document.querySelector('span').innerHTML=data.num &#125; console.log(data); &#125;); 主要的聊天记录都存放在了tsconfig.json文件中 每次会对该文件进行读写操作 源码：https://github.com/zhangzhanhao/socket-chat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用canvas绘制200个运动球]]></title>
      <url>%2F2016%2F11%2F06%2Fcanvas_ball%2F</url>
      <content type="text"><![CDATA[canvas是html5中绘制图片、动画的标签本次使用canvas来绘制运动的小球使其在碰到四周时可以反弹。采用面向对象的方法先定义球的属性（起点，半径，速度，颜色）再定义球的方法（画球，运动） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; canvas&#123; display: block; margin:0 auto; border:1px red solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="canvas"&gt; xxxxx&lt;/canvas&gt;&lt;script&gt; var canvas = document.querySelector("#canvas"); canvas.width = 800; canvas.height = 600; var onOff = false; var ctx = canvas.getContext("2d"); function Arc()&#123; this.x = x; this.y = y; this.r = r; this.color = color; this.speedX = speedX; this.speedY = speedY; &#125; Arc.prototype.drawArc = function()&#123; ctx.save(); ctx.beginPath(); ctx.fillStyle = this.color; ctx.arc(this.x,this.y,this.r,0,Math.PI*2) ctx.fill(); ctx.closePath(); ctx.restore(); &#125; Arc.prototype.move = function()&#123; if(this.x+this.speedX+this.r &gt; canvas.width || this.x+this.speedX-this.r &lt; 0)&#123; this.speedX = -this.speedX; &#125; if(this.y+this.speedY+this.r &gt; canvas.height || this.y+this.speedY-this.r &lt; 0)&#123; this.speedY = - this.speedY; &#125; this.x += this.speedX; this.y += this.speedY; &#125; var arr = []; for(let i = 0;i&lt;200;i++)&#123; var x = random(50,750); var y = random(50,550); var r = random(10,30); var speedX = random(3,10); var speedY = random(3,10); var color = `rgb($&#123;random(0,255)&#125;,$&#123;random(0,255)&#125;,$&#123;random(0,255)&#125;)`; var obj = new Arc(x,y,r,color,speedX,speedY) arr.push(obj); &#125; var timer = null; function ani()&#123; ctx.clearRect(0,0,canvas.width,canvas.height) for(let i = 0;i&lt;arr.length;i++)&#123; arr[i].drawArc(); arr[i].move(); console.log(i) &#125; timer = window.requestAnimationFrame(ani); &#125; ani(); document.onclick = function()&#123; onOff = !onOff; if(onOff)&#123; window.cancelAnimationFrame(timer); &#125;else&#123; ani(); &#125; &#125; function random(a,b)&#123; return Math.ceil(Math.random() * (b-a)+a+1); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native组件之TabBarIOS和WebView]]></title>
      <url>%2F2016%2F09%2F30%2Freactnative_2%2F</url>
      <content type="text"><![CDATA[TabBarIOS这个组件是实现一个app底部常见的tab选项卡，他会根据哪个被选中而显示不同的页面。 属性barTintColor string标签栏的背景颜色。 tintColor string当前被选中的标签图标的颜色。 translucent bool一个布尔值，决定标签栏是否需要半透明化。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import React,&#123; Component &#125; from 'react';import &#123; // 任何的使用都要注册 AppRegistry, Text, View, Image, StyleSheet, TabBarIOS, WebView&#125; from 'react-native';//引入样式import Styles from "./style/style"//class后首字母大写//引入组件//ES5 let MyText=require("./html/MyText")//ES6// import MyText from "./html/MyText"var on=true;class My extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; color:"black" &#125; &#125; color()&#123; var color=this.state.color; if(on)&#123; color="red"; on=false; &#125;else&#123; color="blue"; on=true; &#125; this.setState(&#123; color:color &#125;) &#125; render()&#123; return( ***下面使用时可以自定义 &lt;Text style=&#123;&#123;fontSize:Number(this.props.font), color:this.state.color&#125;&#125; onPress=&#123;this.color.bind(this)&#125;&gt;HAHA&lt;/Text&gt; **第一个this使触发时可以调用自定义color函数 .bind(this)改变自定义函数里面的this可以指向类 ) &#125;&#125;class React1 extends Component&#123; constructor(props)&#123; *******自有函数 super(props) this.state=&#123; *******状态值 times:0, who:"index" &#125; &#125; changeTime()&#123; let times=this.state.times; // alert(times) times++; this.setState(&#123; times:times &#125;) &#125; render()&#123; return( &lt;TabBarIOS unselectedTintColor="gold" tintColor="white" barTintColor="darkslateblue" &gt; &lt;TabBarIOS.Item badge="1" title="首页" icon=&#123;&#123;uri: base64Icon, scale: 3&#125;&#125; selected=&#123;this.state.who=="index"&#125; *selected=&#123;true&#125;时展示的不能为空 onPress=&#123;function () &#123; this.setState(&#123; who:"index" &#125;) &#125;.bind(this)&#125; //****ES5 bind(this) 函数需调整this的指向 //ES6写法 箭头函数自动调整this的指向 // onPress=&#123;() =&gt; &#123; // this.setState(&#123; // selectedTab: 'blueTab', // &#125;); // &#125;&#125;&gt; &gt; *****WebView 引入外部网页 &lt;WebView *展示内容 source=&#123;&#123;uri: 'https://m.baidu.com'&#125;&#125; /&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title="地图" icon=&#123;&#123;uri: base64Icon, scale: 3&#125;&#125; selected=&#123;this.state.who=="map"&#125; onPress=&#123;function () &#123; this.setState(&#123; who:"map" &#125;) &#125;.bind(this)&#125; &gt; *****WebView 引入本地网页 &lt;WebView source=&#123;require("./html/map.html")&#125; /&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title="天气" icon=&#123;&#123;uri: base64Icon, scale: 3&#125;&#125; selected=&#123;this.state.who=="news"&#125; onPress=&#123;function () &#123; this.setState(&#123; who:"news" &#125;) &#125;.bind(this)&#125; &gt; &lt;View style=&#123;&#123;flex:1,justifyContent:"center",alignItems:"center"&#125;&#125;&gt; &lt;Text style=&#123;&#123;fontSize:60&#125;&#125;&gt;新闻&lt;/Text&gt; &lt;MyText/&gt; &lt;My font="10"/&gt; ***自定义属性 通过函数本身this.props.font使用 &lt;My font="20"/&gt; &lt;Text style=&#123;Styles.text&#125; onPress=&#123;this.changeTime.bind(this)&#125;&gt; 点我 &lt;/Text&gt; &lt;Text&gt; 点了&#123;this.state.times&#125;次 &lt;/Text&gt; &lt;/View&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); &#125;&#125;// 注册的 AppRegistry.registerComponent注册的参数必须和init项目名称保持一致AppRegistry.registerComponent('reactTest', function()&#123; return React1;&#125;); WebView这个组件就比较简单粗暴了，可以直接引入写好的html和线上的网站123&lt;WebView source=&#123;&#123;uri: 'https://m.baidu.com'&#125;&#125;/&gt; 或123&lt;WebView source=&#123;require("./html/map.html")&#125;/&gt; 引入外部文件123456789101112131415161718192021222324252627import React,&#123; Component &#125; from 'react';import &#123; StyleSheet&#125; from 'react-native';const styles=StyleSheet.create(&#123; box: &#123; flex: 1, justifyContent: "center", alignItems: "center" &#125;, text:&#123; width:100, textAlign:"center", height:50, lineHeight:50, fontSize:24, color:"red", borderWidth:10, borderColor:"gray" &#125;&#125;);module.exports = styles; // 必须暴露出来 等号后面的名字与const的名字相同 在需要用到的地方用ES5或ES6的方法引入1234//ES5 let MyText=require("./html/MyText")//ES6// import MyText from "./html/MyText" 踩到的坑1&lt;TabBarIOS.Item&gt;&lt;/TabBarIOS.Item&gt; 中间是被选中时要展示的页面，当select判断到状态值与本身相等时如果两个标签中间没有任何展示的东西，在测试的时候就会报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native入门]]></title>
      <url>%2F2016%2F09%2F28%2Freactnative_1%2F</url>
      <content type="text"><![CDATA[React Native介绍React Native (简称RN)是Facebook于2015年四月开源的跨平台移动应用开发框架，是Facebook早先开源的Web UI框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。该框架使用Javascript，类似于HTML的JSX，以及CSS来开发移动应用UI，因此熟悉Web开发的人只需很少的学习成本就可以转入移动应用开发。RN运行时包含一个原生的主线程和一个JS线程，JS线程执行JS代码，负责界面布局和业务逻辑处理，原生线程负责界面渲染和原生组件的执行。RN里面尽量使用原生组件，避免重复造轮子。这样的好处，一是可以利用现有的大量的原生组件，降低入门门槛；二是可以达到跟原生应用一样的性能；三是通过JS封装过后的组件，可以支持跨平台。JS在RN里面的作用类似于Python这样的支持调用原生C库的脚本语言，都是起着“胶水”的作用。复杂计算和底层功能都通过调用原生接口来完成，流程控制和业务逻辑则在“胶水”语言里完成。这样既提高了开发效率，又兼顾了性能。作者：Jagger Wang来源：知乎 最近React Native越来越火，它的设计初衷是实现一套代码，全平台试用，使前端走向了移动端APP的制作，也让越来越多的从事IOS、Android的同学感到恐慌，当然流畅性稍稍不如，但随着React Native的发展这个问题页终将会被解决，总的来说是技术上的突破。 安装HomebrewHomebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件。1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：1sudo chown -R `whoami` /usr/local React Native的命令行工具1npm install -g react-native-cli 如果你看到EACCES: permission denied这样的权限报错 运行:1sudo chown -R `whoami` /usr/local Watchman工具1brew install watchman 测试安装123react-native init AwesomeProjectcd AwesomeProjectreact-native run-ios 编写Hello World以IOS端为例，找到index.ios.js根据历史悠久的“传统”，我们也来写一个“Hello World”：12345678910111213import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text &#125; from 'react-native';class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;Text&gt;Hello world!&lt;/Text&gt; ); &#125;&#125;// 注意，这里用引号括起来的'AwesomeProject'必须和你init创建的项目名一致，箭头后面的‘HelloWorldApp’和类名一致AppRegistry.registerComponent('AwesomeProject', () =&gt; HelloWorldApp); ⌘-R刷新 遇到的坑和解决办法项目初始化失败解决办法修复权限：1sudo chmod 777 ~/.babel.json 跑当前程序却运行以前的程序解决办法清除watchman监控列表1watchman watch-del-all 引入外部http请求解决办法需要用xcode打开本地info.plist把App Transport Security Settings 点开后的 Allow Arbitrary Loads 改成YES 需要注意的地方任何组件在使用前要先引用例如1import &#123; AppRegistry, Text &#125; from 'react-native';]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 主题自定义样式]]></title>
      <url>%2F2016%2F05%2F25%2Fnextcss%2F</url>
      <content type="text"><![CDATA[刚开始搭建博客时就选了一个走简约风格的next主题，用了也好一段时间了，也慢慢有了审美疲劳，于是今天决心改变一下。找了一下，实现了头部样式的自定义，与大家分享一下。 样式文件以我使用的next主题为例，具体其他主题还要找到它自己的样式文件。主题文件夹下source-&gt;css-&gt;_schemes-&gt;Mist下面所有.styl文件都是主题的样式文件，想改哪里就先去页面找到相应的类名，再找到文件中他的样式修改。例如我修改了.menu首先我会找到_menu.styl文件，修改1234567891011121314151617181920212223242526.menu &#123; margin-top: 20px; padding-left:0; text-align:center; background:rgba(255,255,255,0.65); margin-left:auto; margin-right:auto; width:600px; border-radius:initial; +mobile() &#123; margin: 20px 0 0 0; padding: 0; margin-left:0; margin-right:0; width:100%; &#125; br &#123; display: none; &#125; .menu-item &#123; margin: 0; display:inline-block; margin:0 10px; +mobile() &#123; display: block; &#125; &#125; +mobile() {}里面的样式，是主题响应式在手机端的样式，在屏幕宽小于760是就会启用这里面的样式。最终实现了菜单栏居中的样式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo next主题添加留言页面]]></title>
      <url>%2F2016%2F05%2F20%2Fhexo_talk%2F</url>
      <content type="text"><![CDATA[留言板使博客看起来更加人性化，增进博主与游客的互动，NexT 主题官网有给出添加标签页、分类页的方法，其实添加留言本的方式异曲同工。方式稍微会有一点不同。 添加留言本 page进入到博客的根目录，运行命令：1$ hexo new page guestbook 留言本页面中添加多说访客代码上一步中使用 hexo 命令新建了一个 page，进入到博客的source目录，里面会多了一个gusetbook文件夹，里面有一个index.md文件，打开该文件编辑：1&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt; 这段代码加到index.md底部就行。然后要登录自己多说的站点，进入设置-&gt;自定义CSS，添加：123456789101112131415161718#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*設置圖像的長和寬，這裏要根據自己的評論框情況更改*/ border-radius: 27px; /*設置圖像圓角效果,在這裏我直接設置了超過width/2的像素，即為圓形了*/ -webkit-border-radius: 27px; /*圓角效果：兼容webkit瀏覽器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*設置圖像陰影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*隱藏多說底部版權*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 菜单设置中添加留言本找到NexT主题设置的_config.yml文件里面的menu项添加 guestbook: /guestbook 添加多语言文件的值因为这里使用的是中文，找到languages文件夹里面的zh-Hans.yml文件，menu子项中添加留言： guestbook: 留言 原文地址：http://www.jianshu.com/p/f2cfc95cab4e]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[margin:auto的作用]]></title>
      <url>%2F2015%2F04%2F05%2Fcss1%2F</url>
      <content type="text"><![CDATA[我们都知道当给一个块级元素设置了宽高以后，给他一个margin:0 auto；就可以左右居中。其实margin:auto; 还有一些其他作用。 margin—left:auto当一个块级元素设置完宽高后，它会默认靠近父容器的左侧，这时无论怎么设置margin-right的值，这个块级元素的位置都不会变化。但如果我们希望他距离父容器右侧50像素，又不借助定位和浮动，这时就可以用到margin—left:auto； 给他设置12margin-right:50px;margin-left:auto; 他就会移动到距离父容器右侧50像素的位置。 margin:auto实现上下左右居中 margin:auto可以实现左右居中的原因是，块级元素本来是横向填满父容器的，当给他设置了宽以后，其他区域就被强制覆盖掉了，这时设置margin:auto;被强制覆盖掉的区域就会平均分布在这个块级元素的左右，这样就实现了左右居中。 但是，因为块级元素没有默认上下也填充满父级容器的属性，所以这时margin:auto对纵向是不生效的，但是我们依然可以利用类似左右居中的方法来实现上下居中。 12345678910111213141516 .father&#123; height: 600px; position: relative; background-color: lightgray;&#125; .son&#123; background-color: blue; position: absolute; top:0; bottom: 0; left: 0; right: 0; height: 300px; width: 300px; margin: auto;&#125; 原理是子级元素相对父级元素定位设置top:0;bottom: 0;left: 0;right: 0; 这时，子级元素就会继承父级元素的宽高，然后我们在给子级元素设置宽高。这时，子级元素的宽高强行被改变，就在横向和纵向都留出来了一个被覆盖掉的区域，这时给子级元素margin:auto四周遍都有效了，也就实现了子级元素相对父级元素的上下左右居中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo next主题换背景]]></title>
      <url>%2F2015%2F03%2F23%2Fnext_bg%2F</url>
      <content type="text"><![CDATA[之前用hexo在github上搭建了一个博客，next主题以简约出名，但还是想给自己的博客弄张背景。 1首先找到一个背景图片放到 hexo– themes – next – source – images 的路径下； 2hexo– themes – next – source – css – _schemes – Pisces（Mist和Muse也行），找到路径下的index.styl文件，在文件的最上方加上一代码 body { background:url(/images/你之前加的背景图片的名字);}刷新页面背景图片就出来了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github搭建博客]]></title>
      <url>%2F2015%2F03%2F21%2Ffirst-article%2F</url>
      <content type="text"><![CDATA[Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上，引用Hexo作者 @tommy351 的话： 快速、简单且功能强大的 Node.js 博客框架。A fast, simple &amp; powerful blog framework, powered by Node.js.# NodeJS安装 NodeJS安装网址https://nodejs.org/en/下载相应版本的nodeJS 测试安装成功后打开终端输入1$ node -v 安装hexo1$ npm install hexo -g 测试1$ hexo 创建目录并进入创建一个文件夹,cd 文件夹名/ 1$ hexo init 启动本地服务1$ hexo server 下载主题git clone下载主题文件，放在themes文件夹中 更改配置文件在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 更改站点配置文件title:博客名author：作者language:zh-Hans(根据主题文件夹下修改)theme：next（主题文件名）deploy： type:git repo:github的仓库克隆地址duoshuo_shortname:多说评论的shortname 更改主题配置文件以我使用的next主题为例 修改SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题，例如： # Code Highlight theme # Available value: normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: normal 还有很多配置可以修改，具体参考next主题官方网址 发布1$ npm install hexo-deployer-git - -save 编译1$ hexo g 发布1$ hexo d 使用next主题遇到的坑换过主题后在本地启动服务可以正常渲染，当上传到github上以后出现只有一个框架，没有任何文章及控制台大量报错的情况 解决办法把next主题下面的source/vendors文件名改成任意其他名字，如：VEN等，之后在配置文件_config.yml,下面，把vendors: 块，里面的_internal: vendors项改成前面重命名文件夹的名称,如_internal:VEN,保存，hexo clean ,hexo g ,hexo d,再试试看，亲测有效！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2015%2F03%2F20%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
