<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[NodeJS+Socket.io搭建简易聊天室]]></title>
      <url>%2F2016%2F11%2F12%2Fsocket%2F</url>
      <content type="text"><![CDATA[前端一直是一块充满惊喜的土地，不仅是那些富有创造性的页面，还有那些惊赞的效果及不断推出的新技术。像node.js这样的后端开拓者直接将前端人员的能力扩大到了后端。瞬间就有了一统天下的感觉，来往穿梭于前后端之间代码敲得飞起，从此由前端晋升为’前后端’。 需要用到的插件mime1$ npm install mime socket.io1$ npm install socket.io socket.io根据官网代码分为 服务端12345678910111213141516171819202122232425var app = require('http').createServer(handler)var io = require('socket.io')(app);var fs = require('fs');app.listen(80);function handler (req, res) &#123; fs.readFile(__dirname + '/index.html', function (err, data) &#123; if (err) &#123; res.writeHead(500); return res.end('Error loading index.html'); &#125; res.writeHead(200); res.end(data); &#125;);&#125;io.on('connection', function (socket) &#123; socket.emit('news', &#123; hello: 'world' &#125;); socket.on('my other event', function (data) &#123; console.log(data); &#125;);&#125;); 客户端12345678&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://localhost'); socket.on('news', function (data) &#123; console.log(data); socket.emit('my other event', &#123; my: 'data' &#125;); &#125;);&lt;/script&gt; 参考官方代码我做了一个简易聊天室demo以下为我所实现的代码 服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//引入部分var http=require("http")var fs=require("fs")var mime=require("mime")var server=http.createServer(handle)//绑定服务器var io=require("socket.io")(server)function handle(req,res) &#123; var filepath="" if(req.url=="/")&#123; filepath="./public/html/index.html" &#125;else&#123; filepath="./public"+req.url &#125; serverStatic(res,filepath)&#125;function serverStatic(res,filepath) &#123; fs.exists(filepath,function (exists) &#123; if(exists)&#123; fs.readFile(filepath,function (err,data) &#123; if(err)&#123; send404(res) &#125; res.writeHead(200,&#123;"Content-Type":mime.lookup(filepath)&#125;) res.end(data) &#125;) &#125;else&#123; send404(res) &#125; &#125;)&#125;var num=0;io.on('connection', function (socket) &#123; //emit(事件名，&#123;发射主题&#125;) //on(事件名，接收回调) //服务端与客户端一一对应 num++; console.log(num) function fasong() &#123; fs.readFile("./tsconfig.json","utf-8",function (err,data) &#123; if(err)&#123;return&#125; var data=JSON.parse(data) io.sockets.emit('ret',&#123; hello: data.mesg ,num:num&#125;); &#125;) &#125; fasong() socket.on('message', function (info) &#123; fs.readFile("./tsconfig.json","utf-8",function (err,data) &#123; if(err)&#123;return&#125; var data=JSON.parse(data) data.mesg.push(info) fs.writeFile("./tsconfig.json",JSON.stringify(data),function () &#123; fasong() &#125;) &#125;) &#125;);&#125;);function send404(res) &#123; res.writeHead(404,&#123;"Content-Type":"text/plain"&#125;) res.end("404 NOT FOUND")&#125;server.listen(3000,function () &#123; &#125;) 需要解释一下的是，在connection事件的回调函数中，socket表示的是当前连接到服务器的那个客户端。所以代码socket.emit(‘foo’)则只有自己收得到这个事件，而socket.broadcast.emit(‘foo’)则表示向除自己外的所有人发送该事件，另外，上面代码中，io表示服务器整个socket连接，所以代码io.sockets.emit(‘foo’)表示所有人都可以收到该事件。 客户端JS1234567891011121314151617181920var socket = io('http://10.80.13.132:3000'); var mes=document.querySelector(".mes") var btn=document.querySelector(".btn") var ul=document.querySelector('ul') var chat=document.querySelector(".chat") btn.onclick=function (ev) &#123; ev.preventDefault(); var message=mes.value socket.emit('message', &#123; Info: message &#125;); &#125; socket.on('ret', function (data) &#123; ul.innerHTML='' for(var i=0;i&lt;data.hello.length;i++)&#123; var li=document.createElement("li") li.innerHTML=data.hello[i].Info ul.appendChild(li) document.querySelector('span').innerHTML=data.num &#125; console.log(data); &#125;); 主要的聊天记录都存放在了tsconfig.json文件中 每次会对该文件进行读写操作 源码：https://github.com/zhangzhanhao/socket-chat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用canvas绘制200个运动球]]></title>
      <url>%2F2016%2F11%2F06%2Fcanvas_ball%2F</url>
      <content type="text"><![CDATA[canvas是html5中绘制图片、动画的标签本次使用canvas来绘制运动的小球使其在碰到四周时可以反弹。采用面向对象的方法先定义球的属性（起点，半径，速度，颜色）再定义球的方法（画球，运动） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; canvas&#123; display: block; margin:0 auto; border:1px red solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="canvas"&gt; xxxxx&lt;/canvas&gt;&lt;script&gt; var canvas = document.querySelector("#canvas"); canvas.width = 800; canvas.height = 600; var onOff = false; var ctx = canvas.getContext("2d"); function Arc()&#123; this.x = x; this.y = y; this.r = r; this.color = color; this.speedX = speedX; this.speedY = speedY; &#125; Arc.prototype.drawArc = function()&#123; ctx.save(); ctx.beginPath(); ctx.fillStyle = this.color; ctx.arc(this.x,this.y,this.r,0,Math.PI*2) ctx.fill(); ctx.closePath(); ctx.restore(); &#125; Arc.prototype.move = function()&#123; if(this.x+this.speedX+this.r &gt; canvas.width || this.x+this.speedX-this.r &lt; 0)&#123; this.speedX = -this.speedX; &#125; if(this.y+this.speedY+this.r &gt; canvas.height || this.y+this.speedY-this.r &lt; 0)&#123; this.speedY = - this.speedY; &#125; this.x += this.speedX; this.y += this.speedY; &#125; var arr = []; for(let i = 0;i&lt;200;i++)&#123; var x = random(50,750); var y = random(50,550); var r = random(10,30); var speedX = random(3,10); var speedY = random(3,10); var color = `rgb($&#123;random(0,255)&#125;,$&#123;random(0,255)&#125;,$&#123;random(0,255)&#125;)`; var obj = new Arc(x,y,r,color,speedX,speedY) arr.push(obj); &#125; var timer = null; function ani()&#123; ctx.clearRect(0,0,canvas.width,canvas.height) for(let i = 0;i&lt;arr.length;i++)&#123; arr[i].drawArc(); arr[i].move(); console.log(i) &#125; timer = window.requestAnimationFrame(ani); &#125; ani(); document.onclick = function()&#123; onOff = !onOff; if(onOff)&#123; window.cancelAnimationFrame(timer); &#125;else&#123; ani(); &#125; &#125; function random(a,b)&#123; return Math.ceil(Math.random() * (b-a)+a+1); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native组件之TabBarIOS和WebView]]></title>
      <url>%2F2016%2F09%2F30%2Freactnative_2%2F</url>
      <content type="text"><![CDATA[TabBarIOS这个组件是实现一个app底部常见的tab选项卡，他会根据哪个被选中而显示不同的页面。 属性barTintColor string标签栏的背景颜色。 tintColor string当前被选中的标签图标的颜色。 translucent bool一个布尔值，决定标签栏是否需要半透明化。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import React,&#123; Component &#125; from 'react';import &#123; // 任何的使用都要注册 AppRegistry, Text, View, Image, StyleSheet, TabBarIOS, WebView&#125; from 'react-native';//引入样式import Styles from "./style/style"//class后首字母大写//引入组件//ES5 let MyText=require("./html/MyText")//ES6// import MyText from "./html/MyText"var on=true;class My extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; color:"black" &#125; &#125; color()&#123; var color=this.state.color; if(on)&#123; color="red"; on=false; &#125;else&#123; color="blue"; on=true; &#125; this.setState(&#123; color:color &#125;) &#125; render()&#123; return( ***下面使用时可以自定义 &lt;Text style=&#123;&#123;fontSize:Number(this.props.font), color:this.state.color&#125;&#125; onPress=&#123;this.color.bind(this)&#125;&gt;HAHA&lt;/Text&gt; **第一个this使触发时可以调用自定义color函数 .bind(this)改变自定义函数里面的this可以指向类 ) &#125;&#125;class React1 extends Component&#123; constructor(props)&#123; *******自有函数 super(props) this.state=&#123; *******状态值 times:0, who:"index" &#125; &#125; changeTime()&#123; let times=this.state.times; // alert(times) times++; this.setState(&#123; times:times &#125;) &#125; render()&#123; return( &lt;TabBarIOS unselectedTintColor="gold" tintColor="white" barTintColor="darkslateblue" &gt; &lt;TabBarIOS.Item badge="1" title="首页" icon=&#123;&#123;uri: base64Icon, scale: 3&#125;&#125; selected=&#123;this.state.who=="index"&#125; *selected=&#123;true&#125;时展示的不能为空 onPress=&#123;function () &#123; this.setState(&#123; who:"index" &#125;) &#125;.bind(this)&#125; //****ES5 bind(this) 函数需调整this的指向 //ES6写法 箭头函数自动调整this的指向 // onPress=&#123;() =&gt; &#123; // this.setState(&#123; // selectedTab: 'blueTab', // &#125;); // &#125;&#125;&gt; &gt; *****WebView 引入外部网页 &lt;WebView *展示内容 source=&#123;&#123;uri: 'https://m.baidu.com'&#125;&#125; /&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title="地图" icon=&#123;&#123;uri: base64Icon, scale: 3&#125;&#125; selected=&#123;this.state.who=="map"&#125; onPress=&#123;function () &#123; this.setState(&#123; who:"map" &#125;) &#125;.bind(this)&#125; &gt; *****WebView 引入本地网页 &lt;WebView source=&#123;require("./html/map.html")&#125; /&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title="天气" icon=&#123;&#123;uri: base64Icon, scale: 3&#125;&#125; selected=&#123;this.state.who=="news"&#125; onPress=&#123;function () &#123; this.setState(&#123; who:"news" &#125;) &#125;.bind(this)&#125; &gt; &lt;View style=&#123;&#123;flex:1,justifyContent:"center",alignItems:"center"&#125;&#125;&gt; &lt;Text style=&#123;&#123;fontSize:60&#125;&#125;&gt;新闻&lt;/Text&gt; &lt;MyText/&gt; &lt;My font="10"/&gt; ***自定义属性 通过函数本身this.props.font使用 &lt;My font="20"/&gt; &lt;Text style=&#123;Styles.text&#125; onPress=&#123;this.changeTime.bind(this)&#125;&gt; 点我 &lt;/Text&gt; &lt;Text&gt; 点了&#123;this.state.times&#125;次 &lt;/Text&gt; &lt;/View&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); &#125;&#125;// 注册的 AppRegistry.registerComponent注册的参数必须和init项目名称保持一致AppRegistry.registerComponent('reactTest', function()&#123; return React1;&#125;); WebView这个组件就比较简单粗暴了，可以直接引入写好的html和线上的网站123&lt;WebView source=&#123;&#123;uri: 'https://m.baidu.com'&#125;&#125;/&gt; 或123&lt;WebView source=&#123;require("./html/map.html")&#125;/&gt; 引入外部文件123456789101112131415161718192021222324252627import React,&#123; Component &#125; from 'react';import &#123; StyleSheet&#125; from 'react-native';const styles=StyleSheet.create(&#123; box: &#123; flex: 1, justifyContent: "center", alignItems: "center" &#125;, text:&#123; width:100, textAlign:"center", height:50, lineHeight:50, fontSize:24, color:"red", borderWidth:10, borderColor:"gray" &#125;&#125;);module.exports = styles; // 必须暴露出来 等号后面的名字与const的名字相同 在需要用到的地方用ES5或ES6的方法引入1234//ES5 let MyText=require("./html/MyText")//ES6// import MyText from "./html/MyText" 踩到的坑1&lt;TabBarIOS.Item&gt;&lt;/TabBarIOS.Item&gt; 中间是被选中时要展示的页面，当select判断到状态值与本身相等时如果两个标签中间没有任何展示的东西，在测试的时候就会报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native入门]]></title>
      <url>%2F2016%2F09%2F28%2Freactnative_1%2F</url>
      <content type="text"><![CDATA[React Native介绍React Native (简称RN)是Facebook于2015年四月开源的跨平台移动应用开发框架，是Facebook早先开源的Web UI框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。该框架使用Javascript，类似于HTML的JSX，以及CSS来开发移动应用UI，因此熟悉Web开发的人只需很少的学习成本就可以转入移动应用开发。RN运行时包含一个原生的主线程和一个JS线程，JS线程执行JS代码，负责界面布局和业务逻辑处理，原生线程负责界面渲染和原生组件的执行。RN里面尽量使用原生组件，避免重复造轮子。这样的好处，一是可以利用现有的大量的原生组件，降低入门门槛；二是可以达到跟原生应用一样的性能；三是通过JS封装过后的组件，可以支持跨平台。JS在RN里面的作用类似于Python这样的支持调用原生C库的脚本语言，都是起着“胶水”的作用。复杂计算和底层功能都通过调用原生接口来完成，流程控制和业务逻辑则在“胶水”语言里完成。这样既提高了开发效率，又兼顾了性能。作者：Jagger Wang来源：知乎 最近React Native越来越火，它的设计初衷是实现一套代码，全平台试用，使前端走向了移动端APP的制作，也让越来越多的从事IOS、Android的同学感到恐慌，当然流畅性稍稍不如，但随着React Native的发展这个问题页终将会被解决，总的来说是技术上的突破。 安装HomebrewHomebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件。1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：1sudo chown -R `whoami` /usr/local React Native的命令行工具1npm install -g react-native-cli 如果你看到EACCES: permission denied这样的权限报错 运行:1sudo chown -R `whoami` /usr/local Watchman工具1brew install watchman 测试安装123react-native init AwesomeProjectcd AwesomeProjectreact-native run-ios 编写Hello World以IOS端为例，找到index.ios.js根据历史悠久的“传统”，我们也来写一个“Hello World”：12345678910111213import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text &#125; from 'react-native';class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;Text&gt;Hello world!&lt;/Text&gt; ); &#125;&#125;// 注意，这里用引号括起来的'AwesomeProject'必须和你init创建的项目名一致，箭头后面的‘HelloWorldApp’和类名一致AppRegistry.registerComponent('AwesomeProject', () =&gt; HelloWorldApp); ⌘-R刷新 遇到的坑和解决办法项目初始化失败解决办法修复权限：1sudo chmod 777 ~/.babel.json 跑当前程序却运行以前的程序解决办法清除watchman监控列表1watchman watch-del-all 引入外部http请求解决办法需要用xcode打开本地info.plist把App Transport Security Settings 点开后的 Allow Arbitrary Loads 改成YES 需要注意的地方任何组件在使用前要先引用例如1import &#123; AppRegistry, Text &#125; from 'react-native';]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 主题自定义样式]]></title>
      <url>%2F2016%2F05%2F25%2Fnextcss%2F</url>
      <content type="text"><![CDATA[刚开始搭建博客时就选了一个走简约风格的next主题，用了也好一段时间了，也慢慢有了审美疲劳，于是今天决心改变一下。找了一下，实现了头部样式的自定义，与大家分享一下。 样式文件以我使用的next主题为例，具体其他主题还要找到它自己的样式文件。主题文件夹下source-&gt;css-&gt;_schemes-&gt;Mist下面所有.styl文件都是主题的样式文件，想改哪里就先去页面找到相应的类名，再找到文件中他的样式修改。例如我修改了.menu首先我会找到_menu.styl文件，修改1234567891011121314151617181920212223242526.menu &#123; margin-top: 20px; padding-left:0; text-align:center; background:rgba(255,255,255,0.65); margin-left:auto; margin-right:auto; width:600px; border-radius:initial; +mobile() &#123; margin: 20px 0 0 0; padding: 0; margin-left:0; margin-right:0; width:100%; &#125; br &#123; display: none; &#125; .menu-item &#123; margin: 0; display:inline-block; margin:0 10px; +mobile() &#123; display: block; &#125; &#125; +mobile() {}里面的样式，是主题响应式在手机端的样式，在屏幕宽小于760是就会启用这里面的样式。最终实现了菜单栏居中的样式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo next主题添加留言页面]]></title>
      <url>%2F2016%2F05%2F20%2Fhexo_talk%2F</url>
      <content type="text"><![CDATA[留言板使博客看起来更加人性化，增进博主与游客的互动，NexT 主题官网有给出添加标签页、分类页的方法，其实添加留言本的方式异曲同工。方式稍微会有一点不同。 添加留言本 page进入到博客的根目录，运行命令：1$ hexo new page guestbook 留言本页面中添加多说访客代码上一步中使用 hexo 命令新建了一个 page，进入到博客的source目录，里面会多了一个gusetbook文件夹，里面有一个index.md文件，打开该文件编辑：1&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt; 这段代码加到index.md底部就行。然后要登录自己多说的站点，进入设置-&gt;自定义CSS，添加：123456789101112131415161718#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*設置圖像的長和寬，這裏要根據自己的評論框情況更改*/ border-radius: 27px; /*設置圖像圓角效果,在這裏我直接設置了超過width/2的像素，即為圓形了*/ -webkit-border-radius: 27px; /*圓角效果：兼容webkit瀏覽器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*設置圖像陰影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*隱藏多說底部版權*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 菜单设置中添加留言本找到NexT主题设置的_config.yml文件里面的menu项添加 guestbook: /guestbook 添加多语言文件的值因为这里使用的是中文，找到languages文件夹里面的zh-Hans.yml文件，menu子项中添加留言： guestbook: 留言 原文地址：http://www.jianshu.com/p/f2cfc95cab4e]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo next主题换背景]]></title>
      <url>%2F2015%2F03%2F23%2Fnext_bg%2F</url>
      <content type="text"><![CDATA[之前用hexo在github上搭建了一个博客，next主题以简约出名，但还是想给自己的博客弄张背景。 1首先找到一个背景图片放到 hexo– themes – next – source – images 的路径下； 2hexo– themes – next – source – css – _schemes – Pisces（Mist和Muse也行），找到路径下的index.styl文件，在文件的最上方加上一代码 body { background:url(/images/你之前加的背景图片的名字);}刷新页面背景图片就出来了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github搭建博客]]></title>
      <url>%2F2015%2F03%2F21%2Ffirst-article%2F</url>
      <content type="text"><![CDATA[Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上，引用Hexo作者 @tommy351 的话： 快速、简单且功能强大的 Node.js 博客框架。A fast, simple &amp; powerful blog framework, powered by Node.js.# NodeJS安装 NodeJS安装网址https://nodejs.org/en/下载相应版本的nodeJS 测试安装成功后打开终端输入1$ node -v 安装hexo1$ npm install hexo -g 测试1$ hexo 创建目录并进入创建一个文件夹,cd 文件夹名/ 1$ hexo init 启动本地服务1$ hexo server 下载主题git clone下载主题文件，放在themes文件夹中 更改配置文件在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 更改站点配置文件title:博客名author：作者language:zh-Hans(根据主题文件夹下修改)theme：next（主题文件名）deploy： type:git repo:github的仓库克隆地址duoshuo_shortname:多说评论的shortname 更改主题配置文件以我使用的next主题为例 修改SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题，例如： # Code Highlight theme # Available value: normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: normal 还有很多配置可以修改，具体参考next主题官方网址 发布1$ npm install hexo-deployer-git - -save 编译1$ hexo g 发布1$ hexo d 使用next主题遇到的坑换过主题后在本地启动服务可以正常渲染，当上传到github上以后出现只有一个框架，没有任何文章及控制台大量报错的情况 解决办法把next主题下面的source/vendors文件名改成任意其他名字，如：VEN等，之后在配置文件_config.yml,下面，把vendors: 块，里面的_internal: vendors项改成前面重命名文件夹的名称,如_internal:VEN,保存，hexo clean ,hexo g ,hexo d,再试试看，亲测有效！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2015%2F03%2F20%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
