<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[this的值到底是什么]]></title>
      <url>%2F2016%2F11%2F21%2Fthis%E6%8C%87%E5%90%91%2F</url>
      <content type="text"><![CDATA[从开始学了javascript以来，遇到this的指向问题时，虽然到最后问题能够解决，但对于这个this的值一直比较模糊不清。今天在知乎上看到了一篇讲this的值得文章，收益匪浅，所以转载来分享。 作者及出处作者：方应杭链接：https://zhuanlan.zhihu.com/p/23804247来源：知乎 正文你可能遇到过这样的 JS 面试题：123456789var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 打印出的 this 是 objbar() // 打印出的 this 是 window 请解释最后两行函数的值为什么不一样。初学者关于 this 的理解一直很模糊。今天这篇文章就要一次讲清楚了。而且这个解释，你在别的地方看不到。看懂这篇文章，所有关于 this 的面试题，都是小菜。有用请点赞。 函数调用首先需要从函数的调用开始讲起。JS（ES5）里面有三种函数调用形式：123func(p1, p2) obj.child.method(p1, p2)func.call(context, p1, p2) // 先不讲 apply 一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：1func.call(context, p1, p2) 其他两种都是语法糖，可以等价地变为 call 形式：12345func(p1, p2) 等价于func.call(undefined, p1, p2)obj.child.method(p1, p2) 等价于obj.child.method.call(obj.child, p1, p2) 请记下来。（我们称此代码为「转换代码」，方便下文引用）至此我们的函数调用只有一种形式：1func.call(context, p1, p2) 这样，this 就好解释了this，就是上面代码中的 context。就这么简单。 this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。 先看 func(p1, p2) 中的 this 如何确定：当你写下面代码时12345function func()&#123; console.log(this)&#125;func() 等价于12345function func()&#123; console.log(this)&#125;func.call(undefined) // 可以简写为 func.call() 按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则： 如果你传的 context 不是一个对象，那么 window 对象就是默认的 context因此上面的打印结果是 window。如果你希望这里的 this 不是 window，很简单：1func.call(obj) // 那么里面的 this 就是 obj 对象了 再看 obj.child.method(p1, p2) 的 this 如何确定1234567var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;obj.foo() 按照「转换代码」，我们将 obj.foo() 转换为1obj.foo.call(obj) 好了，this 就是 obj。搞定。回到题目：12345678910111213var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 转换为 obj.foo.call(obj)，this 就是 objbar() // 转换为 bar.call()// 由于没有传 context// 所以 this 就是 undefined// 最后浏览器给你一个默认的 this —— window 对象 总结 this 就是你 call 一个函数时，传入的 context。 如果你的函数调用形式不是 call 形式，请按照「转换代码」将其转换为 call 形式。以后你遇到所有跟 this 有关的笔试题，都不会有疑问了。 完。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJS+Mongodb小项目]]></title>
      <url>%2F2016%2F11%2F19%2FnodejsObj%2F</url>
      <content type="text"><![CDATA[这个小项目我们实现一个类似慕课网的常见的网络学习平台，这次主要实现了路由跳转、注册、登录、登录状态保存、课程管理、list页的筛选功能、连接数据库实现前后端交互。有一些地方的样式和布局没有细做还望见谅。 环境web开发框架我使用Express，数据库mongodb，服务端nodejs，前端布局使用jade，用到的其他插件：mongoose实现与数据库的连接，supervisor实时监控代码更新，express-session做登录控制。环境的配置和插件的安装在这里就不细说了。百度一下安装方法很详细。 文件配置主文件项目目录下终端运行：1234$ express MyApp$ cd MyApp$ npm install$ supervisor bin/www 这四步运行完之后网页打开127.0.0.1:3000 就可以看到nodeJS已经开始工作了。 Views由于各个页面都有相同的头部和底部，所以在views目录下创建header.jade和foot.jade这样在每个页面就都可以引入，不用写很多遍。创建课程页class.jade直播和点播都在这个页面创建登录页login.jade和注册页reg.jade创建课程管理页setclass.jade这里说下class.jade布局的写法，因为所有课程都是从数据库吐出来的，所以在渲染课程list时要根据数据的个数，动态渲染list有多少条，在jade中可以使用each in来遍历数据1234567891011div.kecheng ul if(data) -each item,index in data li.listone div.img.fl p.fl= item.title p.fl= item.des p.fl span ￥ span= item.price 其他页面具体的布局就不细说了，大家可以下载我的源文件查看， 设置路由在app.js中引入两个路由文件并设置12345var index = require('./routes/index');var ke = require('./routes/class')·······app.use('/', index);app.use('/class',ke) class.js在routes文件夹下创建另一个路由class.js由于直播和点播在一个页面,所以在链接时我给的是/class/type=1和/class/type=2，class.js代码：1234567891011121314151617var express = require('express');var router = express.Router();var mongo = require("../model/db");router.get('/type=1', function(req, res, next) &#123; mongo.kecheng.find(&#123;"type":"直播"&#125;,function (err,data) &#123; res.render('class', &#123; title: "直播" , data:data&#125;); &#125;)&#125;);router.get('/type=2', function(req, res, next) &#123; mongo.kecheng.find(&#123;"type":"点播"&#125;,function (err,data) &#123; res.render('class', &#123; title: '点播' ,data:data&#125;); &#125;)&#125;);module.exports = router 里面关于数据库的操作我们后面再说，这里主要get到/type=1或/type=2都响应一个class页面。 index.jsget各个字段，响应不同页面123456789101112router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: '首页' &#125;);&#125;);router.get('/login', function(req, res, next) &#123; res.render('login', &#123; title: '登录' &#125;);&#125;);router.get('/reg', function(req, res, next) &#123; res.render('reg', &#123; title: '注册' &#125;);&#125;);router.get('/setclass', function(req, res, next) &#123; res.render('setclass', &#123; title: '上传课程' &#125;);&#125;); 连接数据库本地终端找到数据库文件后启动1./mongod 在项目目录下创建model文件夹用来放置连接数据库文件，文件夹下创建db.js。使用插件monngoose来对数据库进行操作12345678910111213141516171819var mongoose = require("mongoose");mongoose.connect("mongodb://127.0.0.1/user");var userSchema = new mongoose.Schema(&#123; username: String, password: String,&#125;);var classSchema = new mongoose.Schema(&#123; title: String, des: String, type: String, price: String&#125;);module.exports=&#123;kecheng:mongoose.model("class",classSchema,"class"), user:mongoose.model("userMo",userSchema,"userMo") &#125; 数据库下我们一共有两个大集合userSchema和classSchema，一个用来存储用户名和密码，一个用来存储课程信息。 登录验证1234567891011121314151617181920212223242526272829303132var mongo = require("../model/db") //引入操作数据库文件 . . .router.post('/login_k',function (req,res,next) &#123; var username=req.body.username var password=req.body.password mongo.user.findOne(&#123;"username":username&#125;,function (err,user) &#123; console.log(user) if(user)&#123; if(user.password==password)&#123; req.session.user = 1, res.send(&#123; req:req.session, success:1, info:"登录成功" &#125;) &#125;else&#123; res.send(&#123; success:0, info:"用户名或密码错误" &#125;) &#125; &#125;else&#123; res.send(&#123; success:0, info:"用户不存在" &#125;) &#125; &#125;)&#125;) 当服务器post到/login_k后取出参数字段在数据库中查找username是否有该用户，没有该用户就返回success:0,info:”用户不存在”，用户存在就检测密码，密码一致返回session和succsee:1,info:”登录成功”，前端在获取success:1时就会在浏览器种下cookie为期半个小时，期间用户再次进入时就不需要登录，头部右侧也会由登录注册变成注销按键。密码不一致则返回success:0,info:”用户名或密码错误” 注册1234567891011121314151617181920212223242526272829303132333435router.post('/login_reg',function (req,res,next) &#123; var username=req.body.username var password=req.body.password mongo.user.findOne(&#123;"username":username&#125;,function(err,user)&#123; if(err)&#123; res.send(&#123; success:0, info:"注册失败" &#125;) &#125; if(user)&#123; res.send(&#123; success:0, info:"用户已存在" &#125;) &#125;else&#123; mongo.user.create(&#123; username:username, password:password &#125;,function (err,data) &#123; if(err)&#123; res.send(&#123; success:0, info:"注册失败" &#125;) &#125; res.send(&#123; success:1, info:"注册成功" &#125;) &#125;) &#125; &#125;)&#125;) 与登录的原理基本相同，检测到用户名就会显示用户名已存在，没有该用户，则会在数据库中创建一个这个用户，这里需要注意12345mongo.user.create(&#123; username:username, password:password &#125;,function (err,data) &#123; …… 123456……var userSchema = new mongoose.Schema(&#123; username: String, password: String,&#125;);…… 创建用户时使用的字段（冒号前面的username）要和数据库操作文件中的username相同。 课程管理123456789101112131415161718router.post('/setclass',function (req,res,next) &#123; var title=req.body.title var type=req.body.type var des=req.body.des var price=req.body.price mongo.kecheng.create(&#123; title: title, des: des, type: type, price: price &#125;,function (err,data) &#123; if(err)&#123;return&#125; res.send(&#123; success:1, info:"上传成功" &#125;) &#125;)&#125;) 同样也需要注意到使用字段和数据库操作文件中相一致。 class页因为直播和点播使用的是同一个页面，所以在点直播时要显示直播的list，点点播时要显示点播的list，细心人可能发现了，我在上传课程时有一个type字段，会设置是直播还是点播。当然在点直播点播页面时也就会到数据库中查找相应的type，mongo.kecheng.find（{……})找到所有符合要求的信息返回前端渲染页面。 遇到的坑数据库操作文件坑点之前在model文件夹下创建了两个数据库操作文件，想一个用来登录注册，一个用来管理课程，但在第二个数据库操作文件引入的时候就会报错。 解决办法把两个文件合并成一个，最后以对象的形式暴露出去。 class.jade坑点当直播课程为空时，网页无法渲染，会报错。 解决办法加入if判断 数据库占用坑点有时数据库进程被关闭后，重新启动时会显示0.0.0.0：27017已经被占用。 解决办法重新开一个终端输入1ps aux|grep mongod 找到对应进程id杀死1kill -9 pid 项目始终被监控坑点刚开始做时每次运行express myApp都会报错，而且发现jade文件被自动转换成了html又没有开任何进程。 解决办法发现这个是webstorm的问题，把整个webstorm软件关掉，再重新开启一遍就好了。 源码下载：https://github.com/zhangzhanhao/nodejsObj]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mongodb]]></title>
      <url>%2F2016%2F11%2F17%2Fmongodb%2F</url>
      <content type="text"><![CDATA[MongoDB 是一个基于分布式文件存储的数据库。 安装mac为例：官网下载 http://downloads.mongodb.org将解压的文件移动到喜欢的位置1mv -n ~/Downloads/mongodb-osx-x86_64-2.4.6 ~/Applications/mongodb/ 创建数据库目录在根目录 / 下创建 data/db 目录，用于放置mongodb数据，并且给该目录设置权限12sudo mkdir -p /data/dbsudo chown -R 用户名(你自己的) /data 用户名后面有个空格 启动mongodb服务打开终端输入12cd Applications/mongodb/bin./mongod 这时进入http://localhost:27017/ 可以看到mongodb已经开始运行了打开另一个终端输入12cd Applications/mongodb/bin./mongo 在这个终端对数据库进行操作 常用命令db 查看当前连接的DBshow dbs 查看所有数据库use db 切换db 创建数据库use db 有的话直接切换，没有就创建 删除数据可进入数据库db.dropDatabase() 创建一个集合进入数据库执行db.集合名称.insert({}) 删除集合db.集合名称.drop() 搜索find()返回当前集合下的所有数据findOne()返回当前集合下的第一条数据find({过滤条件})根据过滤条件返回匹配的数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJS+Socket.io搭建简易聊天室]]></title>
      <url>%2F2016%2F11%2F12%2Fsocket%2F</url>
      <content type="text"><![CDATA[前端一直是一块充满惊喜的土地，不仅是那些富有创造性的页面，还有那些惊赞的效果及不断推出的新技术。像node.js这样的后端开拓者直接将前端人员的能力扩大到了后端。瞬间就有了一统天下的感觉，来往穿梭于前后端之间代码敲得飞起，从此由前端晋升为’前后端’。 需要用到的插件mime1$ npm install mime socket.io1$ npm install socket.io socket.io根据官网代码分为 服务端12345678910111213141516171819202122232425var app = require('http').createServer(handler)var io = require('socket.io')(app);var fs = require('fs');app.listen(80);function handler (req, res) &#123; fs.readFile(__dirname + '/index.html', function (err, data) &#123; if (err) &#123; res.writeHead(500); return res.end('Error loading index.html'); &#125; res.writeHead(200); res.end(data); &#125;);&#125;io.on('connection', function (socket) &#123; socket.emit('news', &#123; hello: 'world' &#125;); socket.on('my other event', function (data) &#123; console.log(data); &#125;);&#125;); 客户端12345678&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://localhost'); socket.on('news', function (data) &#123; console.log(data); socket.emit('my other event', &#123; my: 'data' &#125;); &#125;);&lt;/script&gt; 参考官方代码我做了一个简易聊天室demo以下为我所实现的代码 服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//引入部分var http=require("http")var fs=require("fs")var mime=require("mime")var server=http.createServer(handle)//绑定服务器var io=require("socket.io")(server)function handle(req,res) &#123; var filepath="" if(req.url=="/")&#123; filepath="./public/html/index.html" &#125;else&#123; filepath="./public"+req.url &#125; serverStatic(res,filepath)&#125;function serverStatic(res,filepath) &#123; fs.exists(filepath,function (exists) &#123; if(exists)&#123; fs.readFile(filepath,function (err,data) &#123; if(err)&#123; send404(res) &#125; res.writeHead(200,&#123;"Content-Type":mime.lookup(filepath)&#125;) res.end(data) &#125;) &#125;else&#123; send404(res) &#125; &#125;)&#125;var num=0;io.on('connection', function (socket) &#123; //emit(事件名，&#123;发射主题&#125;) //on(事件名，接收回调) //服务端与客户端一一对应 num++; console.log(num) function fasong() &#123; fs.readFile("./tsconfig.json","utf-8",function (err,data) &#123; if(err)&#123;return&#125; var data=JSON.parse(data) io.sockets.emit('ret',&#123; hello: data.mesg ,num:num&#125;); &#125;) &#125; fasong() socket.on('message', function (info) &#123; fs.readFile("./tsconfig.json","utf-8",function (err,data) &#123; if(err)&#123;return&#125; var data=JSON.parse(data) data.mesg.push(info) fs.writeFile("./tsconfig.json",JSON.stringify(data),function () &#123; fasong() &#125;) &#125;) &#125;);&#125;);function send404(res) &#123; res.writeHead(404,&#123;"Content-Type":"text/plain"&#125;) res.end("404 NOT FOUND")&#125;server.listen(3000,function () &#123; &#125;) 需要解释一下的是，在connection事件的回调函数中，socket表示的是当前连接到服务器的那个客户端。所以代码socket.emit(‘foo’)则只有自己收得到这个事件，而socket.broadcast.emit(‘foo’)则表示向除自己外的所有人发送该事件，另外，上面代码中，io表示服务器整个socket连接，所以代码io.sockets.emit(‘foo’)表示所有人都可以收到该事件。 客户端JS1234567891011121314151617181920var socket = io('http://10.80.13.132:3000'); var mes=document.querySelector(".mes") var btn=document.querySelector(".btn") var ul=document.querySelector('ul') var chat=document.querySelector(".chat") btn.onclick=function (ev) &#123; ev.preventDefault(); var message=mes.value socket.emit('message', &#123; Info: message &#125;); &#125; socket.on('ret', function (data) &#123; ul.innerHTML='' for(var i=0;i&lt;data.hello.length;i++)&#123; var li=document.createElement("li") li.innerHTML=data.hello[i].Info ul.appendChild(li) document.querySelector('span').innerHTML=data.num &#125; console.log(data); &#125;); 主要的聊天记录都存放在了tsconfig.json文件中 每次会对该文件进行读写操作 源码：https://github.com/zhangzhanhao/socket-chat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用canvas绘制200个运动球]]></title>
      <url>%2F2016%2F11%2F06%2Fcanvas_ball%2F</url>
      <content type="text"><![CDATA[canvas是html5中绘制图片、动画的标签本次使用canvas来绘制运动的小球使其在碰到四周时可以反弹。采用面向对象的方法先定义球的属性（起点，半径，速度，颜色）再定义球的方法（画球，运动） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; canvas&#123; display: block; margin:0 auto; border:1px red solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="canvas"&gt; xxxxx&lt;/canvas&gt;&lt;script&gt; var canvas = document.querySelector("#canvas"); canvas.width = 800; canvas.height = 600; var onOff = false; var ctx = canvas.getContext("2d"); function Arc()&#123; this.x = x; this.y = y; this.r = r; this.color = color; this.speedX = speedX; this.speedY = speedY; &#125; Arc.prototype.drawArc = function()&#123; ctx.save(); ctx.beginPath(); ctx.fillStyle = this.color; ctx.arc(this.x,this.y,this.r,0,Math.PI*2) ctx.fill(); ctx.closePath(); ctx.restore(); &#125; Arc.prototype.move = function()&#123; if(this.x+this.speedX+this.r &gt; canvas.width || this.x+this.speedX-this.r &lt; 0)&#123; this.speedX = -this.speedX; &#125; if(this.y+this.speedY+this.r &gt; canvas.height || this.y+this.speedY-this.r &lt; 0)&#123; this.speedY = - this.speedY; &#125; this.x += this.speedX; this.y += this.speedY; &#125; var arr = []; for(let i = 0;i&lt;200;i++)&#123; var x = random(50,750); var y = random(50,550); var r = random(10,30); var speedX = random(3,10); var speedY = random(3,10); var color = `rgb($&#123;random(0,255)&#125;,$&#123;random(0,255)&#125;,$&#123;random(0,255)&#125;)`; var obj = new Arc(x,y,r,color,speedX,speedY) arr.push(obj); &#125; var timer = null; function ani()&#123; ctx.clearRect(0,0,canvas.width,canvas.height) for(let i = 0;i&lt;arr.length;i++)&#123; arr[i].drawArc(); arr[i].move(); console.log(i) &#125; timer = window.requestAnimationFrame(ani); &#125; ani(); document.onclick = function()&#123; onOff = !onOff; if(onOff)&#123; window.cancelAnimationFrame(timer); &#125;else&#123; ani(); &#125; &#125; function random(a,b)&#123; return Math.ceil(Math.random() * (b-a)+a+1); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native广告页制作]]></title>
      <url>%2F2016%2F10%2F19%2Freactnative_7%2F</url>
      <content type="text"><![CDATA[广告页是个好东西，既可以增强用户体验，有能为app增加收入 广告页制作方案一(广告盖住加载过程)在主页顶部设置一个图片（广告）,宽继承屏幕,高根据状态来改变1234567891011121314constructor(props) &#123; super(props); this.state = &#123; height:height &#125;; this.ad() &#125; ad() &#123; this.timer=setTimeout(() =&gt; &#123; this.setState(&#123; height:0 &#125;) &#125;,2000) &#125; 根据定时器来把他的高度改成0 方案二(用户会看到加载过程)主文件（index.ios.js）设置路由1234567891011121314151617&lt;Navigator initialRoute=&#123;&#123; name: "list", component: Root //默认展示的页面 &#125;&#125; configureScene=&#123;(route)=&gt;&#123; var conf = Navigator.SceneConfigs.HorizontalSwipeJump; conf.gestures = null; // 禁用手势左右滑动 return conf; &#125;&#125; renderScene=&#123;(route, navigator)=&gt; &#123; let Component = route.component return ( &lt;Component &#123;...route.params&#125; navigator=&#123;navigator&#125;/&gt; ) &#125;&#125; /&gt; Root文件1234567891011121314151617181920212223constructor(props) &#123; //进入后就会被执行 super(props); this.state = &#123; bounceValue: new Animated.Value(1) &#125;; &#125; componentDidMount() &#123; const &#123; navigator &#125; = this.props; this.timer = setTimeout(() =&gt; &#123; navigator.resetTo(&#123; component: Index, name: 'Index', isFirst: true &#125;); &#125;,1000) //1000毫秒后路由跳转Index页 &#125; render() &#123; return ( &lt;Animated.Image style=&#123;&#123;width:width,height:height&#125;&#125; source=&#123;require('./img/AD.jpg')&#125; //广告图 /&gt; ） &#125; 方案三(根据数据加载情况)说白了就是数据请求的都拿过来了，我们在显示主页面，要不然就显示广告，方法与方案二相近，只是用到了一个三元运算符12345678910111213141516171819202122232425262728&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt; &#123;this.state.slider? &lt;Navigator initialRoute=&#123;&#123; name:"主页", component:Index &#125;&#125; configureScene=&#123;(route)=&gt;&#123; var conf = Navigator.SceneConfigs.HorizontalSwipeJump; conf.gestures = null; // 禁用手势左右滑动 return conf; &#125;&#125; renderScene=&#123;(route, navigator)=&gt; &#123; let Component = route.component return ( // 传递参数 传递组件使子页面也有这个方法 &lt;Component &#123;...route.params&#125; navigator=&#123;navigator&#125; data=&#123;&#123;slider:this.state.slider,list:this.state.list&#125;&#125;/&gt; ) &#125;&#125; /&gt; : &lt;View style=&#123;styles.loading&#125;&gt; &lt;Image source=&#123;require('./App/img/guanggao.jpg')&#125; style=&#123;&#123;width:width,height:height&#125;&#125; /&gt; &lt;/View&gt; &#125; &lt;/View&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native组件之navigator]]></title>
      <url>%2F2016%2F10%2F16%2Freactnative_6%2F</url>
      <content type="text"><![CDATA[首先来说一下app上的轮播图 react-native-swiper我使用第三方的插件制作轮播图，十分方便1npm i react-native-swiper --save 网址https://github.com/leecade/react-native-swiper里面有很多例子基本上还是先引入，然后在Swiper标签里面写要展示的内容，Swiper里面还有很多配置项可以改 例如：1234567891011121314151617181920212223242526&lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;false&#125; //是否显示按钮 autoplay=&#123;true&#125; //是否自动播放 height=&#123;200&#125; //属性设置 autoplayDirection=&#123;false&#125; //没有选中点的样式 dot=&#123;&lt;View style=&#123;&#123;backgroundColor: 'rgba(0,0,0,.2)', width: 5, height: 5, borderRadius: 4, marginLeft: 3, marginRight: 3, marginTop: 3, marginBottom: 3&#125;&#125; /&gt;&#125; //选中点的样式 activeDot=&#123;&lt;View style=&#123;&#123;backgroundColor: '#000', width: 8, height: 8, borderRadius: 4, marginLeft: 3, marginRight: 3, marginTop: 3, marginBottom: 3&#125;&#125; /&gt;&#125; //点的位置 // paginationStyle=&#123;&#123; // bottom: 10, left: 50, right: 10 // &#125;&#125; //回调函数 返回轮播当前的下标 onMomentumScrollEnd=&#123;(e, state, context) =&gt; console.log('index:', state.index)&#125; &gt; &lt;View style=&#123;styles.slide1&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Hello Swiper&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide2&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Beautiful&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide3&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;And simple&lt;/Text&gt; &lt;/View&gt; &lt;/Swiper&gt; 基本就是这样了 Navigator使用导航器可以让你在应用的不同场景（页面）间进行切换。导航器通过路由对象来分辨不同的场景。利用renderScene方法，导航栏可以根据指定的路由来渲染场景。 一般情况下只在主入口设置一个Navigator12345678910111213141516171819&lt;Navigator //初始化 initialRoute=&#123;&#123; name: "list", component: News //默认展示的页面 &#125;&#125; configureScene=&#123;(route)=&gt;&#123; var conf = Navigator.SceneConfigs.HorizontalSwipeJump; //动画效果 conf.gestures = null; // 禁用手势左右滑动 return conf; &#125;&#125; renderScene=&#123;(route,navigator)=&gt;&#123; //渲染页面 route指initialRoute|navigator指整个组件 let Component=route.component //指News return( // 传递参数 传递组件使子页面也有这个方法 &lt;Component &#123;...route.params&#125; navigator=&#123;navigator&#125;/&gt; ) &#125;&#125; /&gt; 比如我这个主入口加载了一个News组件，在这个组件里面通过this.props就能找到传过去的navigator方法，如果这个News组件里面又想跳转下一个页面，就通过触发一个方法然后使用this.props.navigator.push()就可以跳到下一个组件 例如:123456789show(data)&#123; //console.log(this.props) this.props.navigator.push(&#123; name:"详情", component:Detail, //跳转一个Detail组件 params:data //把数据传过去 &#125;) &#125; News组件内部点击触发show(),并把数据传到下一个组件(Detail)中 Detail又可以通过this.props拿到数据12345678910111213141516class Detail extends Component&#123; back()&#123; //console.log(this.props) this.props.navigator.pop() //把现在显示的组件删除 &#125; render()&#123; // console.log(this.props) return( &lt;View style=&#123;&#123;flex:1,justifyContent:"center",alignItems:"center"&#125;&#125;&gt; &lt;Text style=&#123;&#123;color:"blue",fontSize:50&#125;&#125; onPress=&#123;this.back.bind(this)&#125; &gt;&#123;this.props.title&#125;&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125; 当然想返回上一个组件只要通过this.props.navigator.pop() 把当前组件卸载掉就可以了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native下拉刷新和上拉加载]]></title>
      <url>%2F2016%2F10%2F13%2Freactnative_5%2F</url>
      <content type="text"><![CDATA[例如今日头条这样的app有一个新闻list页，它开始只是向我们展示一定数量的新闻(例如二十条),当用户看完这20条新闻后，再向上拉时就会继续加载20条，当用户在最顶部向下拉时，就会刷新新闻列表，呈现最新的新闻，今天就配合mockjs实现这样一个效果。 首先有两种loading小菊花RefreshControl这一组件可以用在ScrollView或ListView内部，为其添加下拉刷新的功能。当ScrollView处于竖直方向的起点位置（scrollY: 0），此时下拉会触发一个onRefresh事件。 ActivityIndicator显示一个圆形的loading提示符号。 ListView123456789101112131415161718192021222324252627282930313233&lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this._render.bind(this)&#125; //主要数据 renderFooter=&#123;this._footer.bind(this)&#125; //底部要显示的内容 showsVerticalScrollIndicator=&#123;false&#125; //是否显示竖直滚动条 automaticallyAdjustContentInsets=&#123;false&#125; //是否去除顶部空白 enableEmptySections=&#123;true&#125; //去除空白数据的警告 onEndReachedThreshold=&#123;5&#125; //当距离底部5像素时执行onEndReached的函数 onEndReached=&#123;this._fetchMoreData.bind(this,true)&#125; //执行的函数 //下拉刷新 refreshControl=&#123; this.state.havedata? &lt;RefreshControl refreshing=&#123;this.state.isRefreshing&#125; onRefresh=&#123;this._fetchMoreData.bind(this,false)&#125; tintColor="#000" title="Loading..." titleColor="#000" progressBackgroundColor="#ffff00" /&gt; : &lt;RefreshControl refreshing=&#123;this.state.isRefreshing&#125; onRefresh=&#123;this._fetchMoreData.bind(this,false)&#125; tintColor="#000" title="没有数据了" titleColor="#000" progressBackgroundColor="#ffff00" /&gt; &#125; /&gt; 该写的注释基本都写了,这里有一个havedata来判断是显示‘loading…’还是‘没有数据了’ 底部的loading主要是上拉加载时显示出来。上面的listview属性中可以看到renderFooter={this._footer.bind(this)}这个是在listview的下面加了一个部分并展示出来onEndReachedThreshold={5}当距离底部5像素时执行onEndReached的函数onEndReached={this._fetchMoreData.bind(this,true)}执行的函数这样我们就可以执行请求函数来请求数据了。 1234567891011121314151617181920_footer()&#123; if(this.state.havedata)&#123; return( &lt;View&gt; &lt;ActivityIndicator //旋转的loading style=&#123;[styles.centering, &#123;height: 45&#125;]&#125; size="small" /&gt; &lt;Text style=&#123;&#123;textAlign:"center"&#125;&#125;&gt;加载中...&lt;/Text&gt; &lt;/View&gt; ) &#125; else&#123; return( &lt;View style=&#123;styles.nodata&#125;&gt; &lt;Text&gt;没有新内容了&lt;/Text&gt; &lt;/View&gt; ) &#125; &#125; 请求数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647_fetchMoreData(up)&#123; if(this.state.totle==this.state.totles&amp;&amp;this.state.totle!=0)&#123; this.setState(&#123; havedata:false &#125;) return &#125;else &#123; if (up) &#123; //上拉加载 return fetch('http://rap.taobao.org/mockjs/8599/api/homepage?pagenum=a') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; let data = Mock.mock(responseJson); //获得与网页上 Mock数据 一样的数据 if (data.state) &#123; this.state.arr=this.state.arr.concat(data.data); this.state.totle=this.state.totle + data.data.length; this.setState(&#123; // arr:this.state.arr.concat(data.data), // totle:this.state.totle + data.data.length, totles:data.lg, dataSource: ds.cloneWithRows(this.state.arr), &#125;) &#125; &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125; else &#123; //下拉刷新 console.log(this.state.arr) return fetch('http://rap.taobao.org/mockjs/8599/api/homepage?pagenum=a') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; let data = Mock.mock(responseJson); //获得与网页上 Mock数据 一样的数据 if (data.state) &#123; this.state.arr=data.data.concat(this.state.arr); this.state.totle=this.state.totle + data.data.length; this.setState(&#123; dataSource: ds.cloneWithRows(this.state.arr), &#125;) &#125; &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125; &#125; &#125; 通过判断up的值来判断是用户是上来了，还是下拉了，因为mock数据传过来的数据中我设置了一个值来控制新闻的条数，所以当下拉刷新时数据的长度不会改变，上来加载时长度会向上加，这样到最后就会显示没有数据了。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251/** * Created by lanou on 16/10/13. */import React,&#123;Component&#125; from 'react';import &#123; Text, View, StyleSheet, ListView, Image, Dimensions, TouchableOpacity, ActivityIndicator, RefreshControl&#125; from 'react-native';var Icon = require('react-native-vector-icons/FontAwesome');var width= Dimensions.get('window').width;var height=Dimensions.get('window').height;let Mock=require("mockjs")class Index extends Component&#123; constructor(props) &#123; super(props); ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;); this.state = &#123; dataSource: ds.cloneWithRows([]), isRefreshing:false, //下拉刷新时loading最后是否消失 false消失 havedata:true, //控制上方是显示loading 还是 没有数据了 //控制底部显示状态 arr:[], totle:0, totles:0, &#125;; this._fetchMoreData(true) //先加载一遍 &#125; //请求数据的方法 _fetchMoreData(up)&#123; if(this.state.totle==this.state.totles&amp;&amp;this.state.totle!=0)&#123; this.setState(&#123; havedata:false &#125;) return &#125;else &#123; if (up) &#123; //上拉加载 return fetch('http://rap.taobao.org/mockjs/8599/api/homepage?pagenum=a') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; let data = Mock.mock(responseJson); //获得与网页上 Mock数据 一样的数据 if (data.state) &#123; this.state.arr=this.state.arr.concat(data.data); this.state.totle=this.state.totle + data.data.length; this.setState(&#123; // arr:this.state.arr.concat(data.data), // totle:this.state.totle + data.data.length, totles:data.lg, dataSource: ds.cloneWithRows(this.state.arr), &#125;) &#125; &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125; else &#123; //下拉刷新 console.log(this.state.arr) return fetch('http://rap.taobao.org/mockjs/8599/api/homepage?pagenum=a') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; let data = Mock.mock(responseJson); //获得与网页上 Mock数据 一样的数据 if (data.state) &#123; this.state.arr=data.data.concat(this.state.arr); this.state.totle=this.state.totle + data.data.length; this.setState(&#123; dataSource: ds.cloneWithRows(this.state.arr), &#125;) &#125; &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125; &#125; &#125; show(text)&#123; alert(text) this.state.color="red" &#125; _render(rowData)&#123; return( &lt;TouchableOpacity onPress=&#123;this.show.bind(this,rowData.title)&#125; &gt; &lt;View style=&#123;styles.box&#125;&gt; &lt;View style=&#123;styles.class&#125;&gt; &lt;View style=&#123;styles.pic&#125;&gt; &lt;Image source=&#123;&#123;uri:rowData.img&#125;&#125; style=&#123;styles.pics&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.right&#125;&gt; &lt;Text style=&#123;[styles.classtitle,&#123;color:this.state.color&#125;]&#125;&gt;&#123;rowData.title&#125;&lt;/Text&gt; &lt;View style=&#123;styles.info&#125;&gt; &lt;View style=&#123;styles.look&#125;&gt; &lt;Icon name="users"/&gt; &lt;Text&gt;&#123;rowData.look&#125;&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.time&#125;&gt; &lt;Icon name="clock-o"/&gt; &lt;Text&gt;&#123;rowData.time&#125;小时&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125; _footer()&#123; if(this.state.havedata)&#123; return( &lt;View&gt; &lt;ActivityIndicator //旋转的loading style=&#123;[styles.centering, &#123;height: 45&#125;]&#125; size="small" /&gt; &lt;Text style=&#123;&#123;textAlign:"center"&#125;&#125;&gt;加载中...&lt;/Text&gt; &lt;/View&gt; ) &#125; else&#123; return( &lt;View style=&#123;styles.nodata&#125;&gt; &lt;Text&gt;没有新内容了&lt;/Text&gt; &lt;/View&gt; ) &#125; &#125; render()&#123; return( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.header&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;全部课程&lt;/Text&gt; &lt;Icon name="arrow-circle-o-down" style=&#123;styles.down&#125; /&gt; &lt;/View&gt; &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this._render.bind(this)&#125; //主要数据 renderFooter=&#123;this._footer.bind(this)&#125; //底部要显示的内容 showsVerticalScrollIndicator=&#123;false&#125; //是否显示竖直滚动条 automaticallyAdjustContentInsets=&#123;false&#125; //是否去除顶部空白 enableEmptySections=&#123;true&#125; //去除空白数据的警告 onEndReachedThreshold=&#123;5&#125; //当距离底部5像素时执行onEndReached的函数 onEndReached=&#123;this._fetchMoreData.bind(this,true)&#125; //执行的函数 //下拉刷新 refreshControl=&#123; this.state.havedata? &lt;RefreshControl refreshing=&#123;this.state.isRefreshing&#125; onRefresh=&#123;this._fetchMoreData.bind(this,false)&#125; tintColor="#000" title="Loading..." titleColor="#000" progressBackgroundColor="#ffff00" /&gt; : &lt;RefreshControl refreshing=&#123;this.state.isRefreshing&#125; onRefresh=&#123;this._fetchMoreData.bind(this,false)&#125; tintColor="#000" title="没有数据了" titleColor="#000" progressBackgroundColor="#ffff00" /&gt; &#125; /&gt; &lt;/View&gt; ) &#125;&#125;let styles = StyleSheet.create(&#123; container:&#123; flex:1 &#125;, header:&#123; height:60, backgroundColor:"red", justifyContent:"center", alignItems:"center", flexDirection:"row" &#125;, title:&#123; color:"white", fontSize:20 &#125;, down:&#123; color:"white", fontSize:16, paddingLeft:10 &#125;, right:&#123; height:height*0.12, width:width*0.5, justifyContent:"space-between" &#125;, classtitle:&#123; fontSize:20 &#125;, pics:&#123; width:width*0.4, height:height*0.12 &#125;, look:&#123; flexDirection:"row", paddingRight:20, &#125;, time:&#123; flexDirection:"row", &#125;, info:&#123; flexDirection:"row", &#125;, class:&#123; width:width*0.95, height:height*0.14, flexDirection:"row", borderBottomWidth:1, justifyContent:"space-between", borderBottomColor:"lightgray", padding:5 &#125;, box:&#123; width:width, alignItems:"center" &#125;, centering:&#123;&#125;, nodata:&#123; alignItems:"center", height:45, justifyContent:"center" &#125;&#125;)module.exports = Index;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MockJS]]></title>
      <url>%2F2016%2F10%2F11%2Fmockjs%2F</url>
      <content type="text"><![CDATA[使用mockjs来模拟数据。 MockJS阿里巴巴的一帮前端大神为了解决开发时后端还没完成数据输出而无法完成调试的尴尬，从而创造出了MockJS来随机生成数据。当然，这些数据也不是杂乱无章的，它可以根据你的数据类型的需要生成你所需的数据。只需注册一个阿里巴巴的开发者账号就可以使用了http://rap.taobao.org/你可以创建一个我的项目类似这样的一张表，当然变量名后面的一些符号和备注也是有它自己的语法的具体请参照：http://mockjs.com/examples.html创建完这个表以后，可以点一下红色的mock数据这个按键，在里面可以看到生成的数据，如果满意可以点-首页旁边的播放按键，进去之后随便输入点什么，请求—-屏幕右下角会生成一段request starting, url： 这个就是你的数据接口，因为用到json转换，为了保证数据的准确性，我建议点这个url进去之后辅助里面的代码，粘贴到http://www.bejson.com/检测注意mock数据时的规则是否使用多余的引号 导致转译符报错。如果一切正常，那么这个接口就可以用于你的测试工作中了^^]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native-API之Dimensions]]></title>
      <url>%2F2016%2F10%2F10%2Freactnative_4%2F</url>
      <content type="text"><![CDATA[Dimensions用于获取用户设备屏幕的宽高，这样在一些地方的布局中就可以根据百分比来调整位置。 API使用方法12var width= Dimensions.get('window').width;var height=Dimensions.get('window').height; 注意这个API在使用之前，同样需要在开始的时候通过import引入。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native组件之ListView和使用第三方icon]]></title>
      <url>%2F2016%2F10%2F08%2Freactnative_3%2F</url>
      <content type="text"><![CDATA[本篇博客将会讲解app中的列表制作和用第三方图标在工程开发中的使用。 Icon安装首先打开终端进入到我们的工程文件夹下, (不会创建工程的请参考:http://blog.csdn.net/margaret_mo/article/details/51304062)输入: npm install react-native-vector-icons –save (回车)输入: npm install rnpm -g输入: rnpm link (回车)这些执行完以后再xcode打开项目的Info.plist文件 会在最下面看到引入了很多字体文件。 icon的github网址https://github.com/oblador/react-native-vector-icons根据下边 Bundled Icon Sets 选择要使用的图标工程开头引入：1var Icon = require('react-native-vector-icons/FontAwesome'); 后面这个FontAwesome可以根据需要引入不同的图标文件 使用12345&lt;Icon name="rocket" //图片名连接,可以到这个网址搜索:http://ionicons.com/, 使用时:去掉前面的 "icon-" !!!! size=&#123;30&#125; //图片大小 color="red" //图片颜色/&gt; 如果遇到刚使用icon就报错的情况结束进程重新启动项目即可解决使用Icon的TabBarIOS:1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;TabBarIOS&gt; &lt;Icon.TabBarItemIOS title="首页" iconName="home" selected=&#123;this.state.select=="index"&#125; onPress=&#123; ()=&gt;&#123; this.setState(&#123; select:"index" &#125;) &#125; &#125; &gt; &lt;Index/&gt; &lt;/Icon.TabBarItemIOS&gt; &lt;Icon.TabBarItemIOS title="新闻" iconName="star" selected=&#123;this.state.select=="news"&#125; onPress=&#123; ()=&gt;&#123; this.setState(&#123; select:"news" &#125;) &#125; &#125; &gt; &lt;News/&gt; &lt;/Icon.TabBarItemIOS&gt; &lt;Icon.TabBarItemIOS title="设置" iconName="cog" selected=&#123;this.state.select=="setting"&#125; onPress=&#123; ()=&gt;&#123; this.setState(&#123; select:"setting" &#125;) &#125; &#125; &gt; &lt;Setting/&gt; &lt;/Icon.TabBarItemIOS&gt;&lt;/TabBarIOS&gt; 使用上和原生的TabBarIOS基本相同只是有了更多的图标可以使用。 ListViewListView - 一个核心组件，用于高效地显示一个可以垂直滚动的变化的数据列表。最基本的使用方式就是创建一个ListView.DataSource数据源，然后给它传递一个普通的数据数组，再使用数据源来实例化一个ListView组件，并且定义它的renderRow回调函数，这个函数会接受数组中的每个数据作为参数，返回一个可渲染的组件（作为listview的每一行）。由于ListView继承了ScrollView，所以它可以使用所有ScrollView的属性，具体见官方文档上ScrollView的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import React,&#123;Component&#125; from 'react';import &#123; Text, View, StyleSheet, ListView, Image,&#125; from 'react-native';const data=[&#123; title:"aaaa", link:"", pic:"http://img.taopic.com/uploads/allimg/121209/234928-12120Z0543764.jpg", from:"上海", time:20, talk:10, link:"http://www.toutiao.com/i6340576938020569601/?channel=news_society#channel=news_society"&#125;,&#123; title:"aaaa", link:"", pic:"http://img.taopic.com/uploads/allimg/121209/234928-12120Z0543764.jpg", from:"上海", time:20, talk:10, link:"http://www.toutiao.com/i6340576938020569601/?channel=news_society#channel=news_society"&#125;,&#123; title:"aaaa", link:"", pic:"http://img.taopic.com/uploads/allimg/121209/234928-12120Z0543764.jpg", from:"上海", time:20, talk:10, link:"http://www.toutiao.com/i6340576938020569601/?channel=news_society#channel=news_society"&#125;,&#123; title:"aaaa", link:"", pic:"http://img.taopic.com/uploads/allimg/121209/234928-12120Z0543764.jpg", from:"上海", time:20, talk:10, link:"http://www.toutiao.com/i6340576938020569601/?channel=news_society#channel=news_society"&#125;,&#123; title:"aaaa", link:"", pic:"http://img.taopic.com/uploads/allimg/121209/234928-12120Z0543764.jpg", from:"上海", time:20, talk:10, link:"http://www.toutiao.com/i6340576938020569601/?channel=news_society#channel=news_society"&#125;,&#123; title:"aaaa", link:"", pic:"http://img.taopic.com/uploads/allimg/121209/234928-12120Z0543764.jpg", from:"上海", time:20, talk:10, link:"http://www.toutiao.com/i6340576938020569601/?channel=news_society#channel=news_society"&#125;,&#123; title:"aaaa", link:"", pic:"http://img.taopic.com/uploads/allimg/121209/234928-12120Z0543764.jpg", from:"上海", time:20, talk:10, link:"http://www.toutiao.com/i6340576938020569601/?channel=news_society#channel=news_society"&#125;,&#123; title:"aaaa", link:"", pic:"http://img.taopic.com/uploads/allimg/121209/234928-12120Z0543764.jpg", from:"上海", time:20, talk:10, link:"http://www.toutiao.com/i6340576938020569601/?channel=news_society#channel=news_society"&#125;]class Index extends Component&#123; constructor(props) &#123; super(props); var ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;); this.state = &#123; dataSource: ds.cloneWithRows(data), &#125;; &#125; _render(rowData)&#123; return( &lt;View style=&#123;styles.one&#125;&gt; &lt;Text&gt;&#123;rowData.title&#125;&lt;/Text&gt; &lt;View style=&#123;&#123;flexDirection:"row",justifyContent:"space-around"&#125;&#125;&gt; &lt;Image source=&#123;&#123;uri:rowData.pic&#125;&#125; style=&#123;&#123;width:100,height:100&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri:rowData.pic&#125;&#125; style=&#123;&#123;width:100,height:100&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri:rowData.pic&#125;&#125; style=&#123;&#123;width:100,height:100&#125;&#125;/&gt; &lt;/View&gt; &lt;Text&gt;&#123;rowData.from&#125; 评论 &#123;rowData.talk&#125; &#123;rowData.time&#125; 分钟前&lt;/Text&gt; &lt;/View&gt; ) &#125; render() &#123; return ( &lt;View&gt; &lt;View style=&#123;styles.head&#125;&gt; &lt;Text style=&#123;&#123;color:"white",fontSize:24,textAlign:"center",lineHeight:50&#125;&#125;&gt;今日头条&lt;/Text&gt; &lt;/View&gt; &lt;ListView style=&#123;&#123;height:605&#125;&#125; dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this._render.bind(this)&#125; //horizontal=&#123;true&#125; //可以设置横向滚动 默认false //centerContent=&#123;true&#125; //当值为true时，如果滚动视图的内容比视图本身小，则会自动把内容居中放置. /&gt; &lt;/View&gt; ); &#125;&#125;const styles=StyleSheet.create(&#123; head:&#123; height:50, backgroundColor:"red", marginTop:20, &#125;, one:&#123; height:150, paddingLeft:20, paddingRight:20, borderBottomColor:"red", borderBottomWidth:1, &#125;&#125;);module.exports = Index; 这里我们写了一个死的数据来看listview的呈现效果。主要是要把拿到的数据放入到dataSource中,renderRow这个属性里面的函数会根据数据的长度来动态生成多少条信息，然后一起展示出来。想去除右边的滚动条可以将showsVerticalScrollIndicator 属性写为false我们会发现底部的TabBarIOS会挡住最后一个数据一半，这时因为listview顶部默认会留一段空白，解决办法是设置automaticallyAdjustContentInsets={false} 这样我们就可以做出一个像新闻页一样的list列表了^_^]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native组件之TabBarIOS和WebView]]></title>
      <url>%2F2016%2F09%2F30%2Freactnative_2%2F</url>
      <content type="text"><![CDATA[TabBarIOS这个组件是实现一个app底部常见的tab选项卡，他会根据哪个被选中而显示不同的页面。 属性barTintColor string标签栏的背景颜色。 tintColor string当前被选中的标签图标的颜色。 translucent bool一个布尔值，决定标签栏是否需要半透明化。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import React,&#123; Component &#125; from 'react';import &#123; // 任何的使用都要注册 AppRegistry, Text, View, Image, StyleSheet, TabBarIOS, WebView&#125; from 'react-native';//引入样式import Styles from "./style/style"//class后首字母大写//引入组件//ES5 let MyText=require("./html/MyText")//ES6// import MyText from "./html/MyText"var on=true;class My extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; color:"black" &#125; &#125; color()&#123; var color=this.state.color; if(on)&#123; color="red"; on=false; &#125;else&#123; color="blue"; on=true; &#125; this.setState(&#123; color:color &#125;) &#125; render()&#123; return( ***下面使用时可以自定义 &lt;Text style=&#123;&#123;fontSize:Number(this.props.font), color:this.state.color&#125;&#125; onPress=&#123;this.color.bind(this)&#125;&gt;HAHA&lt;/Text&gt; **第一个this使触发时可以调用自定义color函数 .bind(this)改变自定义函数里面的this可以指向类 ) &#125;&#125;class React1 extends Component&#123; constructor(props)&#123; *******自有函数 super(props) this.state=&#123; *******状态值 times:0, who:"index" &#125; &#125; changeTime()&#123; let times=this.state.times; // alert(times) times++; this.setState(&#123; times:times &#125;) &#125; render()&#123; return( &lt;TabBarIOS unselectedTintColor="gold" tintColor="white" barTintColor="darkslateblue" &gt; &lt;TabBarIOS.Item badge="1" title="首页" icon=&#123;&#123;uri: base64Icon, scale: 3&#125;&#125; selected=&#123;this.state.who=="index"&#125; *selected=&#123;true&#125;时展示的不能为空 onPress=&#123;function () &#123; this.setState(&#123; who:"index" &#125;) &#125;.bind(this)&#125; //****ES5 bind(this) 函数需调整this的指向 //ES6写法 箭头函数自动调整this的指向 // onPress=&#123;() =&gt; &#123; // this.setState(&#123; // selectedTab: 'blueTab', // &#125;); // &#125;&#125;&gt; &gt; *****WebView 引入外部网页 &lt;WebView *展示内容 source=&#123;&#123;uri: 'https://m.baidu.com'&#125;&#125; /&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title="地图" icon=&#123;&#123;uri: base64Icon, scale: 3&#125;&#125; selected=&#123;this.state.who=="map"&#125; onPress=&#123;function () &#123; this.setState(&#123; who:"map" &#125;) &#125;.bind(this)&#125; &gt; *****WebView 引入本地网页 &lt;WebView source=&#123;require("./html/map.html")&#125; /&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title="天气" icon=&#123;&#123;uri: base64Icon, scale: 3&#125;&#125; selected=&#123;this.state.who=="news"&#125; onPress=&#123;function () &#123; this.setState(&#123; who:"news" &#125;) &#125;.bind(this)&#125; &gt; &lt;View style=&#123;&#123;flex:1,justifyContent:"center",alignItems:"center"&#125;&#125;&gt; &lt;Text style=&#123;&#123;fontSize:60&#125;&#125;&gt;新闻&lt;/Text&gt; &lt;MyText/&gt; &lt;My font="10"/&gt; ***自定义属性 通过函数本身this.props.font使用 &lt;My font="20"/&gt; &lt;Text style=&#123;Styles.text&#125; onPress=&#123;this.changeTime.bind(this)&#125;&gt; 点我 &lt;/Text&gt; &lt;Text&gt; 点了&#123;this.state.times&#125;次 &lt;/Text&gt; &lt;/View&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); &#125;&#125;// 注册的 AppRegistry.registerComponent注册的参数必须和init项目名称保持一致AppRegistry.registerComponent('reactTest', function()&#123; return React1;&#125;); 这里面有一个setState方法，就是在按下当前这个选项时，把自有函数this.state={}里面的who的值来改成当前选项自己的值，这样例如selected={this.state.who==”index”} 就会判断当前这个who是否等于当前按下的这个选项的who，如果成立就会展示这个选项所对应的页面。再例如第三个页面有一个按钮，被点击后下面的点了多少次也会变化，这也是相同的道理，没点击一下自由函数里面的值就会+1，点了{this.state.times}次，中间恰好展示的是这个次数。 WebView这个组件就比较简单粗暴了，可以直接引入写好的html和线上的网站。 123&lt;WebView source=&#123;&#123;uri: 'https://m.baidu.com'&#125;&#125;/&gt; 或123&lt;WebView source=&#123;require("./html/map.html")&#125;/&gt; 引入外部文件123456789101112131415161718192021222324252627import React,&#123; Component &#125; from 'react';import &#123; StyleSheet&#125; from 'react-native';const styles=StyleSheet.create(&#123; box: &#123; flex: 1, justifyContent: "center", alignItems: "center" &#125;, text:&#123; width:100, textAlign:"center", height:50, lineHeight:50, fontSize:24, color:"red", borderWidth:10, borderColor:"gray" &#125;&#125;);module.exports = styles; // 必须暴露出来 等号后面的名字与const的名字相同 在需要用到的地方用ES5或ES6的方法引入1234//ES5 let MyText=require("./html/MyText")//ES6// import MyText from "./html/MyText" 踩到的坑1&lt;TabBarIOS.Item&gt;&lt;/TabBarIOS.Item&gt; 中间是被选中时要展示的页面，当select判断到状态值与本身相等时如果两个标签中间没有任何展示的东西，在测试的时候就会报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native入门]]></title>
      <url>%2F2016%2F09%2F28%2Freactnative_1%2F</url>
      <content type="text"><![CDATA[React Native介绍React Native (简称RN)是Facebook于2015年四月开源的跨平台移动应用开发框架，是Facebook早先开源的Web UI框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。该框架使用Javascript，类似于HTML的JSX，以及CSS来开发移动应用UI，因此熟悉Web开发的人只需很少的学习成本就可以转入移动应用开发。RN运行时包含一个原生的主线程和一个JS线程，JS线程执行JS代码，负责界面布局和业务逻辑处理，原生线程负责界面渲染和原生组件的执行。RN里面尽量使用原生组件，避免重复造轮子。这样的好处，一是可以利用现有的大量的原生组件，降低入门门槛；二是可以达到跟原生应用一样的性能；三是通过JS封装过后的组件，可以支持跨平台。JS在RN里面的作用类似于Python这样的支持调用原生C库的脚本语言，都是起着“胶水”的作用。复杂计算和底层功能都通过调用原生接口来完成，流程控制和业务逻辑则在“胶水”语言里完成。这样既提高了开发效率，又兼顾了性能。作者：Jagger Wang来源：知乎 最近React Native越来越火，它的设计初衷是实现一套代码，全平台试用，使前端走向了移动端APP的制作，也让越来越多的从事IOS、Android的同学感到恐慌，当然流畅性稍稍不如，但随着React Native的发展这个问题页终将会被解决，总的来说是技术上的突破。 安装HomebrewHomebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件。1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：1sudo chown -R `whoami` /usr/local React Native的命令行工具1npm install -g react-native-cli 如果你看到EACCES: permission denied这样的权限报错 运行:1sudo chown -R `whoami` /usr/local Watchman工具1brew install watchman 测试安装123react-native init AwesomeProjectcd AwesomeProjectreact-native run-ios 编写Hello World以IOS端为例，找到index.ios.js根据历史悠久的“传统”，我们也来写一个“Hello World”：12345678910111213import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text &#125; from 'react-native';class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;Text&gt;Hello world!&lt;/Text&gt; ); &#125;&#125;// 注意，这里用引号括起来的'AwesomeProject'必须和你init创建的项目名一致，箭头后面的‘HelloWorldApp’和类名一致AppRegistry.registerComponent('AwesomeProject', () =&gt; HelloWorldApp); ⌘-R刷新 遇到的坑和解决办法项目初始化失败解决办法修复权限：1sudo chmod 777 ~/.babel.json 跑当前程序却运行以前的程序解决办法清除watchman监控列表1watchman watch-del-all 引入外部http请求解决办法需要用xcode打开本地info.plist把App Transport Security Settings 点开后的 Allow Arbitrary Loads 改成YES 需要注意的地方任何组件在使用前要先引用例如1import &#123; AppRegistry, Text &#125; from 'react-native';]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>%2F2016%2F09%2F13%2F%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[闭包是javascript的一个难点，也是一个特色吧，看过阮一峰的博客受益匪浅。好多人说闭包就是函数里面又套了个函数，在我看来只有内部函数被return时，才形成闭包。闭包就是能够读取其他函数内部变量的函数。引用阮一峰的话：由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 作用那么闭包有什么作用呢？1.可以读取函数内部的变量。2.让这些变量始终存在内存中。123456789101112function f1()&#123; var n=1; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); nAdd(); result(); 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是1，第二次的值是2。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 在结尾的思考题中，这是多加了一行代码，结果就完全不同。12345678910var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); 这里this.name是通过函数直接调用的所以this指向window，输出The Window1234567891011var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); 这里在将this绑定到了object上所以输出 My Object 个人理解，如有错误还望指正]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片懒加载]]></title>
      <url>%2F2016%2F08%2F22%2Flazyimg%2F</url>
      <content type="text"><![CDATA[图片懒加载一般运用到图片较多的页面，电商类的页面一般都有图片懒加载处理。 步骤1.将要懒加载的网页中的图片都设为同一张loading图片；2.给图片设置data-src的属性，保存图片的真实地址；3.当图片滚动到可视区域时，将图片src替换为真实地址。上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding:0; &#125; ul&#123; min-height: 100vh; list-style: none; &#125; li&#123; box-sizing: border-box; float: left; width: 25%; border: 1px solid white; /*background: dodgerblue;*/ &#125; img&#123; height: 300px; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;img data-src="http://img5.imgtn.bdimg.com/it/u=2293326281,3636697318&amp;fm=21&amp;gp=0.jpg" alt=""&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // document.images 获取文档所有img标签，返回数组 // img支持name属性 var img=document.querySelectorAll('img') var scrolltop=document.body.scrollTop; var windowheight=window.innerHeight; var height=document.body.scrollHeight; var src=img[0].getAttribute("data-src") for(var i=0;i&lt;img.length;i++)&#123; if(img[i].offsetTop&lt;windowheight)&#123; img[i].src=src; &#125; &#125; window.onscroll=function () &#123; var img=document.querySelectorAll('img') var scrolltop=document.body.scrollTop; var windowheight=window.innerHeight; var height=document.body.scrollHeight; var src=img[0].getAttribute("data-src") for(var i=0;i&lt;img.length;i++)&#123; if(img[i].offsetTop&lt;=windowheight+scrolltop &amp;&amp; !img[i].src)&#123; img[i].src=src; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样做的好处是页面加载变快，使用户先看到上面的图片，不用等整个网站的图片都加载完成之后再浏览网页，提升了用户体验]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见meta标签以及浏览器私有meta]]></title>
      <url>%2F2016%2F08%2F19%2Fmeta%2F</url>
      <content type="text"><![CDATA[今天看到一篇博客，整理了meta标签的使用方法,存下来一定会用到，感谢原文作者。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!-- 声明文档使用的字符编码 --&gt;&lt;meta charset='utf-8'&gt;&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt;&lt;!-- 页面描述 --&gt;&lt;meta name="description" content="不超过150个字符"/&gt;&lt;!-- 页面关键词 --&gt;&lt;meta name="keywords" content=""/&gt;&lt;!-- 网页作者 --&gt;&lt;meta name="author" content="name, email@gmail.com"/&gt;&lt;!-- 搜索引擎抓取 --&gt;&lt;meta name="robots" content="index,follow"/&gt;&lt;!-- 为移动设备添加 viewport --&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/&gt;&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;!-- iOS 设备 begin --&gt;&lt;meta name="apple-mobile-web-app-title" content="标题"&gt;&lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;&lt;meta name="apple-mobile-web-app-capable" content="yes"/&gt;&lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL"&gt;&lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;&lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;meta name="format-detection" content="telphone=no, email=no"/&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name="HandheldFriendly" content="true"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name="MobileOptimized" content="320"&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name="screen-orientation" content="portrait"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name="x5-orientation" content="portrait"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name="full-screen" content="yes"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name="x5-fullscreen" content="true"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name="browsermode" content="application"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name="x5-page-mode" content="app"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name="msapplication-tap-highlight" content="no"&gt;&lt;!-- iOS 图标 begin --&gt;&lt;link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-57x57-precomposed.png"/&gt;&lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;&lt;link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114x114-precomposed.png"/&gt;&lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;&lt;link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144x144-precomposed.png"/&gt;&lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;&lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt;&lt;link rel="apple-touch-startup-image" sizes="768x1004" href="/splash-screen-768x1004.png"/&gt;&lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;&lt;link rel="apple-touch-startup-image" sizes="1536x2008" href="/splash-screen-1536x2008.png"/&gt;&lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;&lt;link rel="apple-touch-startup-image" sizes="1024x748" href="/Default-Portrait-1024x748.png"/&gt;&lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;&lt;link rel="apple-touch-startup-image" sizes="2048x1496" href="/splash-screen-2048x1496.png"/&gt;&lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel="apple-touch-startup-image" href="/splash-screen-320x480.png"/&gt;&lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt;&lt;link rel="apple-touch-startup-image" sizes="640x960" href="/splash-screen-640x960.png"/&gt;&lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt;&lt;link rel="apple-touch-startup-image" sizes="640x1136" href="/splash-screen-640x1136.png"/&gt;&lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt;&lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt;&lt;meta name="msapplication-TileColor" content="#000"/&gt;&lt;!-- Windows 8 磁贴颜色 --&gt;&lt;meta name="msapplication-TileImage" content="icon.png"/&gt;&lt;!-- Windows 8 磁贴图标 --&gt; &lt;link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"/&gt;&lt;!-- 添加 RSS 订阅 --&gt;&lt;link rel="shortcut icon" type="image/ico" href="/favicon.ico"/&gt;&lt;!-- 添加 favicon icon --&gt;&lt;!-- sns 社交标签 begin --&gt;&lt;!-- 参考微博API --&gt;&lt;meta property="og:type" content="类型" /&gt;&lt;meta property="og:url" content="URL地址" /&gt;&lt;meta property="og:title" content="标题" /&gt;&lt;meta property="og:image" content="图片" /&gt;&lt;meta property="og:description" content="描述" /&gt;&lt;!-- sns 社交标签 end --&gt; 原文：http://azq.space/blog/meta/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[base64]]></title>
      <url>%2F2016%2F08%2F18%2Fbase64%2F</url>
      <content type="text"><![CDATA[在我们访问一个网站时，常常会遇到网站内的图片加载速度非常缓慢，从而影响到我们浏览网页时的用户体验Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。 —转自百度百科 我们可以把图片转换成base64编码，再进行传输，这样就会是图片加载变快提升用户体验。 我常用的网站http://tool.css-js.com/base64.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript基础（四）]]></title>
      <url>%2F2016%2F08%2F17%2Fjavascript%E5%9F%BA%E7%A1%804%2F</url>
      <content type="text"><![CDATA[流程语句。 循环语句while123while(条件表达式)&#123; 循环执行代码段&#125; 先检查后执行 do-while123do&#123;循环执行的代码段&#125;while(条件表达式) 先执行一次循环体，再判断 for例：123for(var i = 0;i&lt;20;i++)&#123;循环代码段&#125; for-in123for(声明变量 in 对象)&#123;代码段&#125; 枚举对象属性 跳出语句return终止函数体的运行，并返回一个值 break终止整个循环，不再进行判断 continue结束本次循环，接着去判断是否执行下次循环 选择语句if1234567if(条件一)&#123;代码段1&#125;else if(条件二)&#123;代码段2&#125;else&#123;代码段3&#125; switch12345678switch(条件表达式)&#123;case 标签1: 代码段1; break; …… default: 代码段n;&#125; 异常处理语句好像不是很常用 throw主动抛出异常 try指向需要处理的代码段 catch捕获异常 finally后期处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript基础（三）]]></title>
      <url>%2F2016%2F08%2F17%2Fjavascript%E5%9F%BA%E7%A1%803%2F</url>
      <content type="text"><![CDATA[一些常用的数组方法 创建方法空数组1var Obj = new Array(); 指定长度数组1var Obj = new Array(Size); 指定元素数组1var Obj = new Array(元素1,元素2……); 单维数组1var Obj = [元素1,元素2……]; 多维数组1var a = new Array([数组序列1],[数组序列2]……); 数组属性constructor引用数组对象的构造函数 length返回数组长度 prototype通过增加属性和方法扩展数组定义 操作数组添加push()数组末尾添加 unshift()数组头部添加 concat()合并两个数组 删除pop()删除并返回数组的最后一个元素 shift()删除并返回数组的第一个元素 子数组spilce()删除任意数量的项 下标 项数指定位置插入指定的项 下标 0 插入的项替换任意数量的项 下标 要删除的项数 要插入的项 slice()从已有数组中选取部分元素构成新数组 数组排序sort()排序–例如：1arr.sort(function(a,b)&#123;return a-b&#125;) reverse()点到数组中元素的顺序 数组转换toSring()转换为字符串并返回 附数组去重办法12345678910var test = [1,2,3,4,5,6,7,7,1,8,8,9]; for (var i = 0; i &lt; test.length; i++) &#123; for (var j=i+1; j &lt; test.length; j++) &#123; if (test[i]===test[j]) &#123; test.splice(j,1); j--; &#125; &#125; &#125; console.log(test); 运用扩展数组去重123456789101112131415161718Array.prototype.unique1 = function()&#123; var res = [this[0]]; for(var i = 1; i &lt; this.length; i++)&#123; var repeat = false; for(var j = 0; j &lt; res.length; j++)&#123; if(this[i] == res[j])&#123; repeat = true; break; &#125; &#125; if(!repeat)&#123; res.push(this[i]); &#125; &#125; return res;&#125;var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1,1,12,3,5,6,5,5,8]console.log(arr.unique1());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript基础（二）]]></title>
      <url>%2F2016%2F08%2F17%2Fjavascript%E5%9F%BA%E7%A1%802%2F</url>
      <content type="text"><![CDATA[常用字符串方法 字符串函数查找方法字符方法charAt()功能：返回字符串中第n个字符参数：超出范围返回空字符串返回值：sting中第n个字符的实际值 charCodeAt()功能：返回字符串中第n个字符的代码参数：超出范围返回NaN返回值：sting中第n个字符的Unicode编码 位置方法indexOf()从前向后检索 字符串，看是否有指定字符，找到返回子串首次出现的下标，没有返回-1。 lastindexOf()从后向前检索 字符串，看是否有指定字符，找到返回子串首次出现的下标，没有返回-1。 匹配方法match()找到一个或多个正则表达式的匹配 search()检索字符串与正则表达式匹配的子串 replace()替换一个与正则表达式匹配的子串 2个参数 split()根据指定分隔符将字符串分割成多个子串，并返回成数组 操作方法拼接方法concat()连接字符串 截取方法slice()根据下标截取子串正数：下标向后截取负数：从后向前数x个，向后截取 substring()根据下标截取子串 负值参数转换为0 substr()根据长度截取子串第一个参数起始下标第二个参数截取长度 空格处理trim清除前后空格 trimLeft清除前置空格 trimRight清除后置空格 编码方法URI字符串编码与解码encodeURI()decodeURI() 转换方法大小写转换toUpperCase()转为大写 toLowerCase()转为小写 PS：纯手打。。累死我了^_^。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript基础（一）]]></title>
      <url>%2F2016%2F08%2F16%2Fjavascript%E5%9F%BA%E7%A1%801%2F</url>
      <content type="text"><![CDATA[这篇开始总结一下js基础，也算是对一年多前端道路的总结。 基础数据类型 String --字符串类型 Number -- 数值类型 Undefined -- undefined（未知）类型 Null -- null（空）类型 Boolean -- 布尔类型 声明变量用var声明的变量会存在变量提升。 保留字、关键字保留字关键字 复合运算符123++ 前置先运算再赋值 和 后置先赋值再运算-- 前置先运算再赋值 和 后置先赋值再运算!! 可以将任何类型的数据转换成布尔类型 数据类型转换toString(); 转换成字符字符串与字符串相加 得到字符串拼接字符串与任意类型相加 得到也是字符串拼接字符串与字符串-/%* 得到的是NaN字符串的特性是 不能修改!! Number();转换成数字true = 1; false = 0; ‘’=0; “44”=44; ‘sdf34’=NaN; Boolean();转换成布尔值true 非空字符串 非零字符（不包含NaN）false 空字符串 0数值和NaN undefined null; isNaN()判断是否是非数NaN的数据类型是number parseInt()截取字符串整数位 （以数字开头） parseFloat()截取字符串小数位 （以数字开头）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[margin-top]]></title>
      <url>%2F2016%2F08%2F15%2Fcss2%2F</url>
      <content type="text"><![CDATA[margin-top有一些坑,记下来。。。 1当给盒子中的第一个元素margin-top的值是，会遇到盒子和这个元素一个向下移动。这是因为盒子没有触发BFC属性。 解决办法1.给盒子加边框2.盒子position:absolute;3.自身浮动4.父级元素overflow:hidden; 2margin-top和上面元素的margin—bottom不会叠加，而会取较大值作为间距，但当这两个元素左右排列时（没有浮动）margin-left和margin-right是可以叠加的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用js停止一个css3动画]]></title>
      <url>%2F2016%2F08%2F15%2Fcss4%2F</url>
      <content type="text"><![CDATA[主要是用到了dom操作的classList属性,这个属性用起来十分方便，不像className属性会影响全部的类名，它可以删除，添加一个类名又不影响其他类名下的样式效果，但针对IE10以下不兼容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style type="text/css"&gt;.div &#123; width: 100px; height: 100px; background: blue; animation: moveto 4s infinite both;&#125; .stop &#123; animation-play-state: paused;&#125;@keyframes moveto &#123; 0% &#123; transform: translate(0px,0px); &#125; 25% &#123; transform: translate(100px,0px); &#125; 50% &#123; transform: translate(100px,100px); &#125; 75%&#123; transform: translate(0px,100px); &#125; 100%&#123; transform: translate(0px,0px); &#125;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="div" id="div"&gt;&lt;/div&gt;&lt;p style="margin-top:110px;"&gt;&lt;input type="button" id="testBtn" value="暂停"&gt;&lt;/p&gt;&lt;script type="text/javascript"&gt; var div = document.getElementById("div"), button = document.getElementById("testBtn"); if (div.classList &amp;&amp; div &amp;&amp; button) &#123; button.onclick = function() &#123; if (this.value == '暂停') &#123; div.classList.add('stop'); this.value = '播放'; &#125; else &#123; div.classList.remove('stop'); this.value = '暂停'; &#125; &#125;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[opcity和rgba]]></title>
      <url>%2F2016%2F08%2F15%2Fcss3%2F</url>
      <content type="text"><![CDATA[例如我们手机微信拆红包时会出现一个半透明层上面有个红包，怎么制作这个透明层呢。。 opcity当给一个元素设置opcity时，这个元素和所在他区域内的其他元素都会变成半透明的样式，所以用这个是无法实现微信红包效果或者底部半透明层上写一个正常不变颜色的字这样的效果，但opcity可以用来实现过度隐藏效果，现在很多网站的轮播图都用到了这个效果。 rgba这个样式的前三个参数是0~255的数字，来确定颜色值，第四个参数是0~1的数字，来确定透明度。这里的透明度的设置不会影响到除它自身外的其他元素，所以用这个样式可以实现微信抢红包的界面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[margin:auto的作用]]></title>
      <url>%2F2016%2F08%2F14%2Fcss1%2F</url>
      <content type="text"><![CDATA[我们都知道当给一个块级元素设置了宽高以后，给他一个margin:0 auto；就可以左右居中。其实margin:auto; 还有一些其他作用。 margin—left:auto当一个块级元素设置完宽高后，它会默认靠近父容器的左侧，这时无论怎么设置margin-right的值，这个块级元素的位置都不会变化。但如果我们希望他距离父容器右侧50像素，又不借助定位和浮动，这时就可以用到margin—left:auto； 给他设置12margin-right:50px;margin-left:auto; 他就会移动到距离父容器右侧50像素的位置。 margin:auto实现上下左右居中 margin:auto可以实现左右居中的原因是，块级元素本来是横向填满父容器的，当给他设置了宽以后，其他区域就被强制覆盖掉了，这时设置margin:auto;被强制覆盖掉的区域就会平均分布在这个块级元素的左右，这样就实现了左右居中。 但是，因为块级元素没有默认上下也填充满父级容器的属性，所以这时margin:auto对纵向是不生效的，但是我们依然可以利用类似左右居中的方法来实现上下居中。 12345678910111213141516 .father&#123; height: 600px; position: relative; background-color: lightgray;&#125; .son&#123; background-color: blue; position: absolute; top:0; bottom: 0; left: 0; right: 0; height: 300px; width: 300px; margin: auto;&#125; 原理是子级元素相对父级元素定位设置top:0;bottom: 0;left: 0;right: 0; 这时，子级元素就会继承父级元素的宽高，然后我们在给子级元素设置宽高。这时，子级元素的宽高强行被改变，就在横向和纵向都留出来了一个被覆盖掉的区域，这时给子级元素margin:auto四周遍都有效了，也就实现了子级元素相对父级元素的上下左右居中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo next主题添加留言页面]]></title>
      <url>%2F2016%2F08%2F13%2Fhexo_talk%2F</url>
      <content type="text"><![CDATA[留言板使博客看起来更加人性化，增进博主与游客的互动，NexT 主题官网有给出添加标签页、分类页的方法，其实添加留言本的方式异曲同工。方式稍微会有一点不同。 添加留言本 page进入到博客的根目录，运行命令：1$ hexo new page guestbook 留言本页面中添加多说访客代码上一步中使用 hexo 命令新建了一个 page，进入到博客的source目录，里面会多了一个gusetbook文件夹，里面有一个index.md文件，打开该文件编辑：1&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt; 这段代码加到index.md底部就行。然后要登录自己多说的站点，进入设置-&gt;自定义CSS，添加：123456789101112131415161718#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*設置圖像的長和寬，這裏要根據自己的評論框情況更改*/ border-radius: 27px; /*設置圖像圓角效果,在這裏我直接設置了超過width/2的像素，即為圓形了*/ -webkit-border-radius: 27px; /*圓角效果：兼容webkit瀏覽器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*設置圖像陰影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*隱藏多說底部版權*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 菜单设置中添加留言本找到NexT主题设置的_config.yml文件里面的menu项添加 guestbook: /guestbook 添加多语言文件的值因为这里使用的是中文，找到languages文件夹里面的zh-Hans.yml文件，menu子项中添加留言： guestbook: 留言 原文地址：http://www.jianshu.com/p/f2cfc95cab4e]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 主题自定义样式]]></title>
      <url>%2F2016%2F08%2F11%2Fnextcss%2F</url>
      <content type="text"><![CDATA[刚开始搭建博客时就选了一个走简约风格的next主题，但是千篇一律难免审美疲劳，于是今天决心改变一下。找了一下，实现了头部样式的自定义，与大家分享一下。 样式文件以我使用的next主题为例，具体其他主题还要找到它自己的样式文件。主题文件夹下source-&gt;css-&gt;_schemes-&gt;Mist下面所有.styl文件都是主题的样式文件，想改哪里就先去页面找到相应的类名，再找到文件中他的样式修改。例如我修改了.menu首先我会找到_menu.styl文件，修改1234567891011121314151617181920212223242526.menu &#123; margin-top: 20px; padding-left:0; text-align:center; background:rgba(255,255,255,0.65); margin-left:auto; margin-right:auto; width:600px; border-radius:initial; +mobile() &#123; margin: 20px 0 0 0; padding: 0; margin-left:0; margin-right:0; width:100%; &#125; br &#123; display: none; &#125; .menu-item &#123; margin: 0; display:inline-block; margin:0 10px; +mobile() &#123; display: block; &#125; &#125; +mobile() {}里面的样式，是主题响应式在手机端的样式，在屏幕宽小于760是就会启用这里面的样式。最终实现了菜单栏居中的样式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo next主题换背景]]></title>
      <url>%2F2016%2F08%2F11%2Fnext_bg%2F</url>
      <content type="text"><![CDATA[之前用hexo在github上搭建了一个博客，next主题以简约出名，但还是想给自己的博客弄张背景。 1首先找到一个背景图片放到 hexo– themes – next – source – images 的路径下； 2hexo– themes – next – source – css – _schemes – Pisces（Mist和Muse也行），找到路径下的index.styl文件，在文件的最上方加上一代码 body { background:url(/images/你之前加的背景图片的名字);}刷新页面背景图片就出来了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github搭建博客]]></title>
      <url>%2F2016%2F08%2F10%2Ffirst-article%2F</url>
      <content type="text"><![CDATA[Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上，引用Hexo作者 @tommy351 的话： 快速、简单且功能强大的 Node.js 博客框架。A fast, simple &amp; powerful blog framework, powered by Node.js.# NodeJS安装 NodeJS安装网址https://nodejs.org/en/下载相应版本的nodeJS 测试安装成功后打开终端输入1$ node -v 安装hexo1$ npm install hexo -g 测试1$ hexo 创建目录并进入创建一个文件夹,cd 文件夹名/ 1$ hexo init 启动本地服务1$ hexo server 下载主题git clone下载主题文件，放在themes文件夹中 更改配置文件在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 更改站点配置文件title:博客名author：作者language:zh-Hans(根据主题文件夹下修改)theme：next（主题文件名）deploy： type:git repo:github的仓库克隆地址duoshuo_shortname:多说评论的shortname 更改主题配置文件以我使用的next主题为例 修改SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties更改 highlight_theme 字段，将其值设定成你所喜爱的高亮主题，例如： # Code Highlight theme # Available value: normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: normal 还有很多配置可以修改，具体参考next主题官方网址 发布1$ npm install hexo-deployer-git - -save 编译1$ hexo g 发布1$ hexo d 使用next主题遇到的坑换过主题后在本地启动服务可以正常渲染，当上传到github上以后出现只有一个框架，没有任何文章及控制台大量报错的情况 解决办法把next主题下面的source/vendors文件名改成任意其他名字，如：VEN等，之后在配置文件_config.yml,下面，把vendors: 块，里面的_internal: vendors项改成前面重命名文件夹的名称,如_internal:VEN,保存，hexo clean ,hexo g ,hexo d,再试试看，亲测有效！！！]]></content>
    </entry>

    
  
  
</search>
